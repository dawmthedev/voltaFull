"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformTest = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const accepts_1 = tslib_1.__importDefault(require("accepts"));
const PlatformBuilder_js_1 = require("../builder/PlatformBuilder.js");
const PlatformContext_js_1 = require("../domain/PlatformContext.js");
const createInjector_js_1 = require("../utils/createInjector.js");
const getConfiguration_js_1 = require("../utils/getConfiguration.js");
const FakeResponse_1 = require("./FakeResponse");
const PlatformApplication_js_1 = require("./PlatformApplication.js");
/**
 * @platform
 */
class PlatformTest extends di_1.DITest {
    static async create(settings = {}) {
        di_1.DITest.injector = PlatformTest.createInjector((0, getConfiguration_js_1.getConfiguration)(settings));
        await di_1.DITest.createContainer();
    }
    /**
     * Create a new injector with the right default services
     */
    static createInjector(settings = {}) {
        return (0, createInjector_js_1.createInjector)({
            settings: di_1.DITest.configure({ httpPort: false, httpsPort: false, ...settings })
        });
    }
    /**
     * Load the server silently without listening port and configure it on test profile.
     * @decorator
     * @param mod
     * @param listen
     * @param settings
     * @returns {Promise<void>}
     */
    static bootstrap(mod, { listen, ...settings } = {}) {
        return async function before() {
            let instance;
            const adapter = settings.platform || settings.adapter || PlatformTest.adapter;
            /* istanbul ignore next */
            if (!adapter) {
                throw new Error("Platform adapter is not specified. Have you added at least `import @tsed/platform-express` (or equivalent) on your Server.ts ?");
            }
            // @ts-ignore
            settings = di_1.DITest.configure(settings);
            settings.adapter = adapter;
            const configuration = (0, getConfiguration_js_1.getConfiguration)(settings, mod);
            const disableComponentsScan = configuration.disableComponentsScan || !!process.env.WEBPACK;
            if (!disableComponentsScan) {
                const { importProviders } = await Promise.resolve().then(() => tslib_1.__importStar(require("@tsed/components-scan")));
                await importProviders(configuration);
            }
            instance = await PlatformBuilder_js_1.PlatformBuilder.build(mod, configuration).bootstrap();
            await instance.listen(!!listen);
            // used by inject method
            di_1.DITest.injector = instance.injector;
        };
    }
    /**
     * It injects services into the test function where you can alter, spy on, and manipulate them.
     *
     * The inject function has two parameters
     *
     * * an array of Service dependency injection tokens,
     * * a test function whose parameters correspond exactly to each item in the injection token array.
     *
     * @param targets
     * @param func
     */
    static inject(targets, func) {
        return async () => {
            if (!di_1.DITest.hasInjector()) {
                await PlatformTest.create();
            }
            const injector = di_1.DITest.injector;
            const deps = [];
            for (const target of targets) {
                deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));
            }
            return func(...deps);
        };
    }
    /**
     * Return the raw application (express or koa).
     * Use this callback with SuperTest.
     *
     * ```typescript
     * let request: SuperTest.Agent;
     * beforeEach(PlatformTest.bootstrap(Server, {
     *   mount: {
     *     "/rest": [ProductsController]
     *   }
     * }));
     * beforeEach(() => {
     *   request = SuperTest(PlatformTest.callback());
     * });
     * ```
     */
    static callback() {
        return di_1.DITest.injector.get(PlatformApplication_js_1.PlatformApplication)?.callback();
    }
    static createRequest(options = {}) {
        return {
            headers: {},
            method: "GET",
            url: "/",
            query: {},
            get(key) {
                return this.headers[key.toLowerCase()];
            },
            accepts(mime) {
                return (0, accepts_1.default)(this).types([].concat(mime));
            },
            ...options
        };
    }
    static createResponse(options = {}) {
        return new FakeResponse_1.FakeResponse(options);
    }
    static createRequestContext(options = {}) {
        const event = {
            ...options.event,
            request: options?.request?.request || options?.event?.request || PlatformTest.createRequest(),
            response: options?.response?.response || options?.event?.response || PlatformTest.createResponse()
        };
        const $ctx = new PlatformContext_js_1.PlatformContext({
            id: "id",
            injector: di_1.DITest.injector,
            logger: di_1.DITest.injector.logger,
            url: "/",
            ...options,
            event
        });
        if (options.endpoint) {
            $ctx.endpoint = options.endpoint;
        }
        return $ctx;
    }
}
exports.PlatformTest = PlatformTest;
//# sourceMappingURL=PlatformTest.js.map