{"version":3,"file":"di.umd.min.js","mappings":"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","sources":["webpack://@tsed/di/webpack/universalModuleDefinition","webpack://@tsed/di/external umd \"@tsed/core\"","webpack://@tsed/di/external umd \"@tsed/schema\"","webpack://@tsed/di/webpack/bootstrap","webpack://@tsed/di/webpack/runtime/define property getters","webpack://@tsed/di/webpack/runtime/hasOwnProperty shorthand","webpack://@tsed/di/webpack/runtime/make namespace object","webpack://@tsed/di/./src/common/constants/constants.ts","webpack://@tsed/di/./src/common/domain/ProviderScope.ts","webpack://@tsed/di/./src/common/domain/ProviderType.ts","webpack://@tsed/di/./src/common/domain/LocalsContainer.ts","webpack://@tsed/di/./node_modules/tslib/tslib.es6.mjs","webpack://@tsed/di/./src/common/errors/InvalidPropertyTokenError.ts","webpack://@tsed/di/./src/common/utils/getConstructorDependencies.ts","webpack://@tsed/di/./src/common/decorators/inject.ts","webpack://@tsed/di/./src/common/decorators/configuration.ts","webpack://@tsed/di/./src/common/domain/Provider.ts","webpack://@tsed/di/./src/common/registries/GlobalProviders.ts","webpack://@tsed/di/./src/common/registries/ProviderRegistry.ts","webpack://@tsed/di/./src/common/decorators/injectable.ts","webpack://@tsed/di/./src/common/domain/Container.ts","webpack://@tsed/di/./src/common/domain/InjectablePropertyType.ts","webpack://@tsed/di/./src/common/utils/colors.ts","webpack://@tsed/di/./src/common/errors/InjectionError.ts","webpack://@tsed/di/./src/common/errors/UndefinedTokenError.ts","webpack://@tsed/di/./src/common/utils/createContainer.ts","webpack://@tsed/di/./src/common/utils/resolveControllers.ts","webpack://@tsed/di/./src/common/services/DIConfiguration.ts","webpack://@tsed/di/./src/common/services/InjectorService.ts","webpack://@tsed/di/./src/common/decorators/autoInjectable.ts","webpack://@tsed/di/./src/common/decorators/constant.ts","webpack://@tsed/di/./src/common/decorators/controller.ts","webpack://@tsed/di/./src/common/decorators/intercept.ts","webpack://@tsed/di/./src/common/decorators/interceptor.ts","webpack://@tsed/di/./src/common/decorators/lazyInject.ts","webpack://@tsed/di/./src/common/decorators/module.ts","webpack://@tsed/di/./src/common/decorators/scope.ts","webpack://@tsed/di/./src/common/decorators/opts.ts","webpack://@tsed/di/./src/common/decorators/overrideProvider.ts","webpack://@tsed/di/./src/common/decorators/service.ts","webpack://@tsed/di/./src/common/decorators/useOpts.ts","webpack://@tsed/di/./src/common/decorators/value.ts","webpack://@tsed/di/./src/common/domain/ControllerProvider.ts","webpack://@tsed/di/./src/common/services/DILogger.ts","webpack://@tsed/di/./src/common/utils/getConfiguration.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@tsed/core\"), require(\"@tsed/schema\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@tsed/core\", \"@tsed/schema\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@tsed/di\"] = factory(require(\"@tsed/core\"), require(\"@tsed/schema\"));\n\telse\n\t\troot[\"@tsed/di\"] = factory(root[\"@tsed/core\"], root[\"@tsed/schema\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__803__, __WEBPACK_EXTERNAL_MODULE__953__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__803__;","module.exports = __WEBPACK_EXTERNAL_MODULE__953__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const INJECTABLE_PROP = \"DI:INJECTABLE_PROP\";\nexport const DI_PARAMS = \"DI:PARAMS\";\nexport const DI_PARAM_OPTIONS = \"DI:PARAM:OPTIONS\";\n","export var ProviderScope;\n(function (ProviderScope) {\n    ProviderScope[\"SINGLETON\"] = \"singleton\";\n    ProviderScope[\"REQUEST\"] = \"request\";\n    ProviderScope[\"INSTANCE\"] = \"instance\";\n})(ProviderScope || (ProviderScope = {}));\n","export var ProviderType;\n(function (ProviderType) {\n    ProviderType[\"VALUE\"] = \"value\";\n    ProviderType[\"FACTORY\"] = \"factory\";\n    ProviderType[\"SERVICE\"] = \"service\";\n    ProviderType[\"PROVIDER\"] = \"provider\";\n    ProviderType[\"MODULE\"] = \"module\";\n    ProviderType[\"CONTROLLER\"] = \"controller\";\n    ProviderType[\"INTERCEPTOR\"] = \"interceptor\";\n    ProviderType[\"MIDDLEWARE\"] = \"middleware\";\n})(ProviderType || (ProviderType = {}));\n","import { Hooks } from \"@tsed/core\";\nexport class LocalsContainer extends Map {\n    constructor() {\n        super(...arguments);\n        this.hooks = new Hooks();\n    }\n    async destroy() {\n        await this.hooks.asyncEmit(\"$onDestroy\");\n    }\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n","import { classOf, nameOf } from \"@tsed/core\";\nexport class InvalidPropertyTokenError extends Error {\n    constructor(target, propertyKey) {\n        super(`Object isn't a valid token. Please check the token set on ${nameOf(classOf(target))}.${propertyKey}.\\n- Check that it is not a circular reference.\\n- Check that the token (class or symbol) exists`);\n        this.name = \"INVALID_TOKEN_ERROR\";\n    }\n}\n","import { Metadata } from \"@tsed/core\";\nexport function getConstructorDependencies(target, propertyKey) {\n    return Metadata.getOwn(\"override:ctor:design:paramtypes\", target, propertyKey) || [...Metadata.getParamTypes(target, propertyKey)] || [];\n}\nexport function setConstructorDependencies(target, deps) {\n    Metadata.set(\"override:ctor:design:paramtypes\", deps, target);\n}\n","import { decoratorTypeOf, DecoratorTypes, isPromise, Metadata, Store, UnsupportedDecoratorType } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { InvalidPropertyTokenError } from \"../errors/InvalidPropertyTokenError.js\";\nimport { getConstructorDependencies, setConstructorDependencies } from \"../utils/getConstructorDependencies.js\";\nexport function injectProperty(target, propertyKey, options) {\n    Store.from(target).merge(INJECTABLE_PROP, {\n        [propertyKey]: {\n            bindingType: DecoratorTypes.PROP,\n            propertyKey,\n            ...options\n        }\n    });\n}\n/**\n * Inject a provider to another provider.\n *\n * Use this decorator to inject a custom provider on constructor parameter or property.\n *\n * ```typescript\n * @Injectable()\n * export class MyService {\n *   @Inject(CONNECTION)\n *   connection: CONNECTION;\n * }\n * ```\n *\n * @param token A token provider or token provider group\n * @param onGet Use the given name method to inject\n * @returns {Function}\n * @decorator\n */\nexport function Inject(token, onGet = (bean) => bean) {\n    return (target, propertyKey, descriptor) => {\n        const bindingType = decoratorTypeOf([target, propertyKey, descriptor]);\n        switch (bindingType) {\n            case DecoratorTypes.PARAM_CTOR:\n                if (token) {\n                    const paramTypes = getConstructorDependencies(target, propertyKey);\n                    const type = paramTypes[descriptor];\n                    paramTypes[descriptor] = type === Array ? [token] : token;\n                    Metadata.setParamTypes(target, propertyKey, paramTypes);\n                    setConstructorDependencies(target, paramTypes);\n                }\n                break;\n            case DecoratorTypes.PROP:\n                const useType = token || Metadata.getType(target, propertyKey);\n                if (useType === Object) {\n                    throw new InvalidPropertyTokenError(target, String(propertyKey));\n                }\n                injectProperty(target, String(propertyKey), {\n                    resolver(injector, locals, { options, ...invokeOptions }) {\n                        const originalType = Metadata.getType(target, propertyKey);\n                        locals.set(DI_PARAM_OPTIONS, { ...options });\n                        if (originalType === Array) {\n                            let bean;\n                            if (!bean) {\n                                bean = injector.getMany(token, locals, invokeOptions);\n                                locals.delete(DI_PARAM_OPTIONS);\n                            }\n                            bean.forEach((instance, index) => {\n                                if (isPromise(bean)) {\n                                    instance.then((result) => {\n                                        bean[index] = result;\n                                    });\n                                }\n                            });\n                            return () => onGet(bean);\n                        }\n                        let bean;\n                        if (!bean) {\n                            bean = injector.invoke(useType, locals, invokeOptions);\n                            locals.delete(DI_PARAM_OPTIONS);\n                        }\n                        if (isPromise(bean)) {\n                            bean.then((result) => {\n                                bean = result;\n                            });\n                        }\n                        return () => onGet(bean);\n                    }\n                });\n                break;\n            default:\n                throw new UnsupportedDecoratorType(Inject, [target, propertyKey, descriptor]);\n        }\n    };\n}\n","import { decoratorTypeOf, DecoratorTypes, StoreSet } from \"@tsed/core\";\nimport { Inject } from \"./inject.js\";\n/**\n * Get or set Configuration on a class.\n *\n * @decorator\n */\nexport function Configuration(configuration = {}) {\n    return (...args) => {\n        switch (decoratorTypeOf(args)) {\n            case DecoratorTypes.CLASS:\n                StoreSet(\"configuration\", configuration)(args[0]);\n                break;\n            default:\n            case DecoratorTypes.PARAM_CTOR:\n                return Inject(Configuration)(args[0], args[1], args[2]);\n        }\n    };\n}\n","import { classOf, getClassOrSymbol, isClass, methodsOf, nameOf, Store } from \"@tsed/core\";\nimport { ProviderScope } from \"./ProviderScope.js\";\nimport { ProviderType } from \"./ProviderType.js\";\nexport class Provider {\n    constructor(token, options = {}) {\n        /**\n         * Token group provider to retrieve all provider from the same type\n         */\n        this.type = ProviderType.PROVIDER;\n        this.provide = token;\n        this.useClass = token;\n        Object.assign(this, options);\n    }\n    get token() {\n        return this._provide;\n    }\n    get provide() {\n        return this._provide;\n    }\n    set provide(value) {\n        if (value) {\n            this._provide = getClassOrSymbol(value);\n            this._tokenStore = this._store = Store.from(value);\n        }\n    }\n    get useClass() {\n        return this._useClass;\n    }\n    /**\n     * Create a new store if the given value is a class. Otherwise the value is ignored.\n     * @param value\n     */\n    set useClass(value) {\n        if (isClass(value)) {\n            this._useClass = classOf(value);\n            this._store = Store.from(value);\n            this.hooks = methodsOf(this._useClass).reduce((hooks, { propertyKey }) => {\n                if (String(propertyKey).startsWith(\"$\")) {\n                    return {\n                        ...hooks,\n                        [propertyKey]: (instance, ...args) => instance[propertyKey](...args)\n                    };\n                }\n                return hooks;\n            }, {});\n        }\n    }\n    get className() {\n        return this.name;\n    }\n    get name() {\n        return nameOf(this.provide);\n    }\n    get store() {\n        return this._store;\n    }\n    get path() {\n        return this.store.get(\"path\", \"/\");\n    }\n    set path(path) {\n        this.store.set(\"path\", path);\n    }\n    /**\n     * Get the scope of the provider.\n     *\n     * ::: tip Note\n     * Async provider is always a SINGLETON\n     * :::\n     *\n     * @returns {boolean}\n     */\n    get scope() {\n        if (this.isAsync()) {\n            return ProviderScope.SINGLETON;\n        }\n        return this.get(\"scope\");\n    }\n    /**\n     * Change the scope value of the provider.\n     * @param scope\n     */\n    set scope(scope) {\n        this.store.set(\"scope\", scope);\n    }\n    get configuration() {\n        return this.get(\"configuration\");\n    }\n    set configuration(configuration) {\n        this.store.set(\"configuration\", configuration);\n    }\n    get children() {\n        return this.store.get(\"childrenControllers\", []);\n    }\n    get(key) {\n        return this.store.get(key) || this._tokenStore.get(key);\n    }\n    isAsync() {\n        return !!this.useAsyncFactory;\n    }\n    clone() {\n        return new (classOf(this))(this._provide, this);\n    }\n    /**\n     *\n     * @returns {boolean}\n     */\n    hasChildren() {\n        return !!this.children.length;\n    }\n    /**\n     *\n     * @returns {boolean}\n     */\n    hasParent() {\n        return !!this.store.get(\"parentController\");\n    }\n    toString() {\n        return [\n            \"Token\",\n            this.name,\n            this.useClass && nameOf(this.useClass),\n            this.useFactory && \"Factory\",\n            this.useValue && \"Value\",\n            this.useAsyncFactory && \"AsyncFactory\"\n        ]\n            .filter(Boolean)\n            .join(\":\");\n    }\n}\n","import { getClassOrSymbol } from \"@tsed/core\";\nimport { Provider } from \"../domain/Provider.js\";\nimport { ProviderType } from \"../domain/ProviderType.js\";\nexport class GlobalProviderRegistry extends Map {\n    constructor() {\n        super(...arguments);\n        this.#settings = new Map();\n    }\n    #settings;\n    /**\n     * The get() method returns a specified element from a Map object.\n     * @param key Required. The key of the element to return from the Map object.\n     * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.\n     */\n    get(key) {\n        return super.get(getClassOrSymbol(key));\n    }\n    /**\n     * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n     * @param key\n     * @returns {boolean}\n     */\n    has(key) {\n        return super.has(getClassOrSymbol(key));\n    }\n    /**\n     * The set() method adds or updates an element with a specified key and value to a Map object.\n     * @param key Required. The key of the element to add to the Map object.\n     * @param metadata Required. The value of the element to add to the Map object.\n     */\n    set(key, metadata) {\n        super.set(getClassOrSymbol(key), metadata);\n        return this;\n    }\n    /**\n     *\n     * @param target\n     * @param options\n     */\n    merge(target, options) {\n        const meta = this.createIfNotExists(target, options);\n        Object.keys(options).forEach((key) => {\n            meta[key] = options[key];\n        });\n        this.set(target, meta);\n        return meta;\n    }\n    /**\n     * The delete() method removes the specified element from a Map object.\n     * @param key Required. The key of the element to remove from the Map object.\n     * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.\n     */\n    delete(key) {\n        return super.delete(getClassOrSymbol(key));\n    }\n    createRegistry(type, model, options = {}) {\n        const defaultOptions = this.getRegistrySettings(type);\n        options = Object.assign(defaultOptions, {\n            ...options,\n            model\n        });\n        this.#settings.set(type, options);\n        return this;\n    }\n    onInvoke(provider, locals, options) {\n        const settings = this.#settings.get(provider.type);\n        if (settings?.onInvoke) {\n            settings.onInvoke(provider, locals, options);\n        }\n    }\n    getRegistrySettings(target) {\n        let type = \"provider\";\n        if (typeof target === \"string\") {\n            type = target;\n        }\n        else {\n            const provider = this.get(target);\n            if (provider) {\n                type = provider.type;\n            }\n        }\n        return (this.#settings.get(type) || {\n            model: Provider\n        });\n    }\n    createRegisterFn(type) {\n        return (provider, instance) => {\n            provider = Object.assign({ instance }, provider, { type });\n            this.merge(provider.provide, provider);\n        };\n    }\n    /**\n     *\n     * @param key\n     * @param options\n     */\n    createIfNotExists(key, options) {\n        const type = options.type || ProviderType.PROVIDER;\n        if (!this.has(key)) {\n            const { model = Provider } = this.#settings.get(type) || {};\n            const item = new model(key, options);\n            this.set(key, item);\n        }\n        return this.get(key);\n    }\n}\n/**\n *\n * @type {GlobalProviders}\n */\n// tslint:disable-next-line: variable-name\nexport const GlobalProviders = new GlobalProviderRegistry();\n","import { Provider } from \"../domain/Provider.js\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\nimport { ProviderType } from \"../domain/ProviderType.js\";\nimport { GlobalProviders } from \"./GlobalProviders.js\";\n/**\n *\n */\nGlobalProviders.createRegistry(ProviderType.CONTROLLER, Provider);\n/**\n * Register a provider configuration.\n * @param {ProviderOpts<any>} provider\n */\nexport function registerProvider(provider) {\n    if (!provider.provide) {\n        throw new Error(\"Provider.provide is required\");\n    }\n    return GlobalProviders.merge(provider.provide, provider);\n}\n/**\n * Add a new value in the `ProviderRegistry`.\n *\n * #### Example with symbol definition\n *\n *\n * ```typescript\n * import {registerValue, InjectorService} from \"@tsed/di\";\n *\n * const MyValue = Symbol.from(\"MyValue\")\n *\n * registerValue({token: MyValue, useValue: \"myValue\"});\n *\n * @Service()\n * export class OtherService {\n *      constructor(@Inject(MyValue) myValue: string){\n *          console.log(myValue); /// \"myValue\"\n *      }\n * }\n * ```\n */\nexport const registerValue = (provider, value) => {\n    if (!provider.provide) {\n        provider = {\n            provide: provider\n        };\n    }\n    provider = Object.assign({\n        scope: ProviderScope.SINGLETON,\n        useValue: value\n    }, provider, { type: ProviderType.VALUE });\n    GlobalProviders.merge(provider.provide, provider);\n};\n/**\n * Add a new controller in the `ProviderRegistry`. This controller will be built when `InjectorService` will be loaded.\n *\n * #### Example\n *\n * ```typescript\n * import {registerController, InjectorService} from \"@tsed/di\";\n *\n * export default class MyController {\n *     constructor(){}\n *     transform() {\n *         return \"test\";\n *     }\n * }\n *\n * registerController({provide: MyController});\n * // or\n * registerController(MyController);\n *\n * const injector = new InjectorService();\n * injector.load();\n *\n * const myController = injector.get<MyController>(MyController);\n * myController.getFoo(); // test\n * ```\n *\n * @param provider Provider configuration.\n */\nexport const registerController = GlobalProviders.createRegisterFn(ProviderType.CONTROLLER);\n","import { registerProvider } from \"../registries/ProviderRegistry.js\";\n/**\n * The decorators `@Injectable()` declare a new service can be injected in other service, controller, interceptor, etc.. on there `constructor`.\n * All classes annotated with `@Injectable()` are built one time, excepted if you change the default provider configuration.\n *\n * ::: tip\n * `@Injectable()` use the `reflect-metadata` to collect and inject the built provided to other services.\n * :::\n *\n * ### Options\n *\n * - type (@@ProviderType@@  or `string`): Kind of provider. (Default: `ProviderType.PROVIDER`)\n * - scope (@@ProviderScope@@): Kind of provider. (Default: `ProviderScope.SINGLETON`)\n * - provide (@@TokenProvider@@): An injection token (Note: This option override default metadata generated by Typescript).\n * - deps (`Type<any>`): List of class or provider which will be injected to the constructor (Note: This options override default metadata generated by Typescript).\n *\n * @returns {Function}\n * @decorator\n */\nexport function Injectable(options = {}) {\n    return (target) => {\n        registerProvider({\n            ...options,\n            ...(options.provide ? { useClass: target } : { provide: target })\n        });\n    };\n}\n","import { GlobalProviders } from \"../registries/GlobalProviders.js\";\nimport { Provider } from \"./Provider.js\";\nexport class Container extends Map {\n    /**\n     *\n     * @param token\n     * @param settings\n     */\n    add(token, settings = {}) {\n        const provider = GlobalProviders.get(token)?.clone() || new Provider(token);\n        Object.assign(provider, settings);\n        return super.set(token, provider);\n    }\n    /**\n     * Add a provider to the\n     * @param token\n     * @param settings\n     */\n    addProvider(token, settings = {}) {\n        return this.add(token, settings);\n    }\n    /**\n     *\n     * @param token\n     */\n    hasProvider(token) {\n        return super.has(token);\n    }\n    /**\n     * Add a provider to the\n     * @param token\n     * @param provider\n     */\n    setProvider(token, provider) {\n        return super.set(token, provider);\n    }\n    /**\n     * The getProvider() method returns a specified element from a Map object.\n     * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.\n     * @param token\n     */\n    getProvider(token) {\n        return super.get(token);\n    }\n    /**\n     * Get all providers registered in the injector container.\n     *\n     * @param {ProviderType} type Filter the list by the given ProviderType.\n     * @returns {[TokenProvider , Provider<any>][]}\n     */\n    getProviders(type) {\n        const types = [].concat(type);\n        return [...this].reduce((providers, [_, provider]) => {\n            if (types.includes(provider.type) || !type) {\n                return [...providers, provider];\n            }\n            return providers;\n        }, []);\n    }\n    addProviders(container) {\n        container.forEach((provider) => {\n            if (!this.hasProvider(provider.provide)) {\n                this.setProvider(provider.provide, provider.clone());\n            }\n        });\n    }\n}\n","export var InjectablePropertyType;\n(function (InjectablePropertyType) {\n    InjectablePropertyType[\"METHOD\"] = \"method\";\n    InjectablePropertyType[\"PROPERTY\"] = \"property\";\n    InjectablePropertyType[\"CONSTANT\"] = \"constant\";\n    InjectablePropertyType[\"VALUE\"] = \"value\";\n    InjectablePropertyType[\"INTERCEPTOR\"] = \"interceptor\";\n})(InjectablePropertyType || (InjectablePropertyType = {}));\n","// istanbul ignore next\nconst colorIfAllowed = (colorFn) => (text) => !process.env.NO_COLOR && process.env.NODE_ENV !== \"production\" ? colorFn(text) : text;\nconst red = colorIfAllowed((text) => `\\x1B[31m${text}\\x1B[39m`);\nconst yellow = colorIfAllowed((text) => `\\x1B[33m${text}\\x1B[39m`);\nconst green = colorIfAllowed((text) => `\\x1B[32m${text}\\x1B[39m`);\nexport const colors = { red, yellow, green };\n","import { getConstructorArgNames, isClass, isString, nameOf } from \"@tsed/core\";\nimport { colors } from \"../utils/colors.js\";\nexport class InjectionError extends Error {\n    constructor(token, origin) {\n        super(isString(origin) ? origin : \"\");\n        this.name = \"INJECTION_ERROR\";\n        this.tokens = [];\n        this.tokens = [token];\n        if (origin) {\n            if (isString(origin)) {\n                this.origin = {\n                    message: origin,\n                    stack: this.stack\n                };\n            }\n            else {\n                if (origin.tokens) {\n                    this.tokens = this.tokens.concat(origin.tokens);\n                    this.origin = origin.origin;\n                }\n                else {\n                    this.origin = origin;\n                    this.stack = origin.stack;\n                }\n            }\n        }\n        const originMessage = this.origin ? \"\\nOrigin: \" + this.origin.message : \"\";\n        const tokensMessage = this.tokens.map((token) => nameOf(token)).join(\" > \");\n        this.message = `Injection failed on ${tokensMessage}${originMessage}`;\n    }\n    static throwInjectorError(token, currentDependency, error) {\n        if (currentDependency && isClass(token)) {\n            error.message = printDependencyInjectionError(token, { ...currentDependency, message: error.message });\n        }\n        throw new InjectionError(token, error);\n    }\n}\nfunction printDependencyInjectionError(token, options) {\n    let erroredArg = \"\";\n    const args = getConstructorArgNames(token)\n        .map((arg, index) => {\n        if (options.index === index) {\n            erroredArg = arg;\n            arg = colors.red(arg);\n        }\n        return `${arg}: ${nameOf(options.deps[index])}`;\n    })\n        .join(\", \");\n    const signature = nameOf(token) + \"->constructor(\" + args + \")\";\n    const indexOf = signature.indexOf(erroredArg) - 5;\n    const drawline = (indexOf) => \" \".repeat(indexOf) + colors.red(\"^\" + \"\".repeat(erroredArg.length - 1));\n    return \"Unable to inject dependency. \" + options.message + \"\\n\\n\" + signature + \"\\n\" + (indexOf > -1 ? drawline(indexOf) : \"\");\n}\n","export class UndefinedTokenError extends Error {\n    constructor() {\n        super(\"Given token is undefined. Have you enabled emitDecoratorMetadata in your tsconfig.json or decorated your class with @Injectable, @Service, ... decorator ?\");\n        this.name = \"UNDEFINED_TOKEN_ERROR\";\n    }\n}\n","import { Container } from \"../domain/Container.js\";\nimport { GlobalProviders } from \"../registries/GlobalProviders.js\";\nexport function createContainer(rootModule) {\n    const container = new Container(GlobalProviders.entries());\n    if (rootModule) {\n        container.delete(rootModule);\n    }\n    return container;\n}\n","import { isArray, isClass } from \"@tsed/core\";\nimport { GlobalProviders } from \"../registries/GlobalProviders.js\";\nimport { ProviderType } from \"../domain/ProviderType.js\";\nconst lookupProperties = [\"mount\", \"imports\"];\nexport function getTokens(config) {\n    if (!config) {\n        return [];\n    }\n    if (isArray(config)) {\n        return config.filter(isClass).map((value) => {\n            return { token: value };\n        });\n    }\n    return Object.keys(config).reduce((list, route) => {\n        return [\n            ...list,\n            ...[]\n                .concat(config[route])\n                .filter(isClass)\n                .map((token) => ({\n                route,\n                token\n            }))\n        ];\n    }, []);\n}\nfunction resolveRecursively(providers) {\n    return providers\n        .map(({ token }) => GlobalProviders.get(token))\n        .filter((provider) => provider?.type === ProviderType.MODULE && provider.configuration)\n        .flatMap((provider) => resolveControllers(provider.configuration));\n}\n/**\n * Return controllers and is base route according to his configuration in module configuration.\n *\n * @param settings\n */\nexport function resolveControllers(settings) {\n    const providers = lookupProperties.flatMap((property) => getTokens(settings[property]));\n    return [...resolveRecursively(providers), ...providers].filter((provider) => !!provider.route);\n}\n","import { getValue, proxyDelegation, setValue } from \"@tsed/core\";\nexport class DIConfiguration {\n    constructor(initialProps = {}) {\n        this.default = new Map();\n        this.map = new Map();\n        Object.entries({\n            scopes: {},\n            resolvers: [],\n            imports: [],\n            routes: [],\n            logger: {},\n            ...initialProps\n        }).forEach(([key, value]) => {\n            this.default.set(key, value);\n        });\n        return proxyDelegation(this, {\n            ownKeys(target) {\n                return [...target.default.keys(), ...target.map.keys()];\n            }\n        });\n    }\n    get version() {\n        return this.get(\"version\");\n    }\n    set version(v) {\n        this.map.set(\"version\", v);\n    }\n    get rootDir() {\n        return this.get(\"rootDir\");\n    }\n    set rootDir(value) {\n        this.map.set(\"rootDir\", value);\n    }\n    get env() {\n        return this.map.get(\"env\");\n    }\n    set env(value) {\n        this.map.set(\"env\", value);\n    }\n    get scopes() {\n        return this.map.get(\"scopes\");\n    }\n    set scopes(value) {\n        this.map.set(\"scopes\", value);\n    }\n    get resolvers() {\n        return this.getRaw(\"resolvers\");\n    }\n    set resolvers(resolvers) {\n        this.map.set(\"resolvers\", resolvers);\n    }\n    get imports() {\n        return this.get(\"imports\");\n    }\n    set imports(imports) {\n        this.map.set(\"imports\", imports);\n    }\n    get routes() {\n        return this.get(\"routes\");\n    }\n    set routes(routes) {\n        this.map.set(\"routes\", routes);\n    }\n    get logger() {\n        return this.get(\"logger\");\n    }\n    set logger(value) {\n        const logger = { ...this.logger, ...value };\n        this.map.set(\"logger\", logger);\n    }\n    get debug() {\n        return this.logger.level === \"debug\";\n    }\n    set debug(debug) {\n        this.logger = { ...this.logger, level: debug ? \"debug\" : \"info\" };\n    }\n    /**\n     *\n     * @param callbackfn\n     * @param thisArg\n     */\n    forEach(callbackfn, thisArg) {\n        return new Set([...Array.from(this.default.keys()), ...Array.from(this.map.keys())]).forEach((key) => {\n            callbackfn(this.getRaw(key), key, this.map);\n        }, thisArg);\n    }\n    /**\n     *\n     * @param propertyKey\n     * @param value\n     */\n    set(propertyKey, value) {\n        if (typeof propertyKey === \"string\") {\n            if (Reflect.has(this, propertyKey)) {\n                // @ts-ignore\n                this[propertyKey] = value;\n            }\n            else {\n                this.setRaw(propertyKey, value);\n            }\n        }\n        else {\n            Object.entries(propertyKey).forEach(([key, value]) => {\n                this.set(key, value);\n            });\n        }\n        return this;\n    }\n    setRaw(propertyKey, value) {\n        setValue(this.map, propertyKey, value);\n        return this;\n    }\n    /**\n     *\n     * @param propertyKey\n     * @param defaultValue\n     * @returns {undefined|any}\n     */\n    get(propertyKey, defaultValue) {\n        return this.getRaw(propertyKey, defaultValue);\n    }\n    /**\n     *\n     * @param value\n     * @returns {any}\n     */\n    resolve(value) {\n        return value.replace(\"${rootDir}\", this.rootDir);\n    }\n    getRaw(propertyKey, defaultValue) {\n        const value = getValue(this.map, propertyKey);\n        if (value !== undefined) {\n            return value;\n        }\n        return getValue(this.default, propertyKey, defaultValue);\n    }\n}\n","var InjectorService_1;\nimport { __decorate, __metadata } from \"tslib\";\nimport { ancestorsOf, catchError, classOf, deepClone, deepMerge, Hooks, isArray, isClass, isFunction, isInheritedFrom, isPromise, nameOf, Store } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { Configuration } from \"../decorators/configuration.js\";\nimport { Injectable } from \"../decorators/injectable.js\";\nimport { Container } from \"../domain/Container.js\";\nimport { InjectablePropertyType } from \"../domain/InjectablePropertyType.js\";\nimport { LocalsContainer } from \"../domain/LocalsContainer.js\";\nimport { Provider } from \"../domain/Provider.js\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\nimport { InjectionError } from \"../errors/InjectionError.js\";\nimport { UndefinedTokenError } from \"../errors/UndefinedTokenError.js\";\nimport { GlobalProviders } from \"../registries/GlobalProviders.js\";\nimport { createContainer } from \"../utils/createContainer.js\";\nimport { getConstructorDependencies } from \"../utils/getConstructorDependencies.js\";\nimport { resolveControllers } from \"../utils/resolveControllers.js\";\nimport { DIConfiguration } from \"./DIConfiguration.js\";\nlet globalInjector;\n/**\n * This service contain all services collected by `@Service` or services declared manually with `InjectorService.factory()` or `InjectorService.service()`.\n *\n * ### Example:\n *\n * ```typescript\n * import {InjectorService} from \"@tsed/di\";\n *\n * // Import the services (all services are decorated with @Service()\";\n * import MyService1 from \"./services/service1.js\";\n * import MyService2 from \"./services/service2.js\";\n * import MyService3 from \"./services/service3.js\";\n *\n * // When all services are imported, you can load InjectorService.\n * const injector = new InjectorService()\n *\n * await injector.load();\n *\n * const myService1 = injector.get<MyService1>(MyServcice1);\n * ```\n */\nlet InjectorService = InjectorService_1 = class InjectorService extends Container {\n    #cache;\n    #hooks;\n    constructor() {\n        super();\n        this.settings = new DIConfiguration();\n        this.logger = console;\n        this.resolvedConfiguration = false;\n        this.#cache = new LocalsContainer();\n        this.#hooks = new Hooks();\n        this.#cache.set(InjectorService_1, this);\n        globalInjector = this;\n    }\n    get resolvers() {\n        return this.settings.resolvers;\n    }\n    get scopes() {\n        return this.settings.scopes || {};\n    }\n    static resolveAutoInjectableArgs(token, locals, args) {\n        if (!globalInjector) {\n            throw new Error(\"InjectorService instance is not created yet.\");\n        }\n        const deps = getConstructorDependencies(token);\n        const list = [];\n        const length = Math.max(deps.length, args.length);\n        for (let i = 0; i < length; i++) {\n            if (args[i] !== undefined) {\n                list.push(args[i]);\n            }\n            else {\n                const value = deps[i];\n                const instance = isArray(value)\n                    ? globalInjector.getMany(value[0], locals, { parent: token })\n                    : globalInjector.invoke(value, locals, { parent: token });\n                list.push(instance);\n            }\n        }\n        return list;\n    }\n    static bind(instance, locals) {\n        globalInjector.bindInjectableProperties(instance, locals, {});\n    }\n    /**\n     * Retrieve default scope for a given provider.\n     * @param provider\n     */\n    scopeOf(provider) {\n        return provider.scope || this.scopes[provider.type] || ProviderScope.SINGLETON;\n    }\n    /**\n     * Return a list of instance build by the injector.\n     */\n    toArray() {\n        return [...this.#cache.values()];\n    }\n    /**\n     * Get a service or factory already constructed from his symbol or class.\n     *\n     * #### Example\n     *\n     * ```typescript\n     * import {InjectorService} from \"@tsed/di\";\n     * import MyService from \"./services.js\";\n     *\n     * class OtherService {\n     *      constructor(injectorService: InjectorService) {\n     *          const myService = injectorService.get<MyService>(MyService);\n     *      }\n     * }\n     * ```\n     *\n     * @param token The class or symbol registered in InjectorService.\n     * @param options\n     * @returns {boolean}\n     */\n    get(token, options = {}) {\n        const instance = this.getInstance(token);\n        if (instance !== undefined) {\n            return instance;\n        }\n        if (!this.hasProvider(token)) {\n            for (const resolver of this.resolvers) {\n                const result = resolver.get(token, options);\n                if (result !== undefined) {\n                    return result;\n                }\n            }\n        }\n    }\n    /**\n     * Return all instance of the same provider type\n     * @param type\n     * @param locals\n     * @param options\n     */\n    getMany(type, locals, options) {\n        return this.getProviders(type).map((provider) => this.invoke(provider.token, locals, options));\n    }\n    /**\n     * The has() method returns a boolean indicating whether an element with the specified key exists or not.\n     * @returns {boolean}\n     * @param token\n     */\n    has(token) {\n        return this.#cache.get(token) !== undefined;\n    }\n    alias(token, alias) {\n        this.#cache.set(alias, this.#cache.get(token));\n        return this;\n    }\n    /**\n     * Invoke the class and inject all services that required by the class constructor.\n     *\n     * #### Example\n     *\n     * ```typescript\n     * import {InjectorService} from \"@tsed/di\";\n     * import MyService from \"./services.js\";\n     *\n     * class OtherService {\n     *     constructor(injectorService: InjectorService) {\n     *          const myService = injectorService.invoke<MyService>(MyService);\n     *      }\n     *  }\n     * ```\n     *\n     * @param token The injectable class to invoke. Class parameters are injected according constructor signature.\n     * @param locals  Optional object. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n     * @param options\n     * @returns {Type} The class constructed.\n     */\n    invoke(token, locals, options = {}) {\n        let instance = locals ? locals.get(token) : undefined;\n        if (instance !== undefined) {\n            return instance;\n        }\n        if (token === Configuration) {\n            return this.settings;\n        }\n        instance = !options.rebuild ? this.getInstance(token) : undefined;\n        if (instance != undefined) {\n            return instance;\n        }\n        if (token === DI_PARAM_OPTIONS) {\n            return {};\n        }\n        const provider = this.ensureProvider(token);\n        const set = (instance) => {\n            this.#cache.set(token, instance);\n            provider?.alias && this.alias(token, provider.alias);\n        };\n        if (!provider || options.rebuild) {\n            instance = this.resolve(token, locals, options);\n            if (this.hasProvider(token)) {\n                set(instance);\n            }\n            return instance;\n        }\n        instance = this.resolve(token, locals, options);\n        switch (this.scopeOf(provider)) {\n            case ProviderScope.SINGLETON:\n                if (provider.hooks && !options.rebuild) {\n                    this.registerHooks(provider, instance);\n                }\n                if (!provider.isAsync() || !isPromise(instance)) {\n                    set(instance);\n                    return instance;\n                }\n                // store promise to lock token in cache\n                set(instance);\n                instance = instance.then((instance) => {\n                    set(instance);\n                    return instance;\n                });\n                return instance;\n            case ProviderScope.REQUEST:\n                if (locals) {\n                    locals.set(token, instance);\n                    if (provider.hooks && provider.hooks.$onDestroy) {\n                        locals.hooks.on(\"$onDestroy\", (...args) => provider.hooks.$onDestroy(instance, ...args));\n                    }\n                }\n                return instance;\n        }\n        return instance;\n    }\n    /**\n     * Build only providers which are asynchronous.\n     */\n    async loadAsync() {\n        for (const [, provider] of this) {\n            if (!this.has(provider.token) && provider.isAsync()) {\n                await this.invoke(provider.token);\n            }\n        }\n    }\n    loadSync() {\n        for (const [, provider] of this) {\n            if (!this.has(provider.token) && this.scopeOf(provider) === ProviderScope.SINGLETON) {\n                this.invoke(provider.token);\n            }\n        }\n    }\n    /**\n     * Boostrap injector from container and resolve configuration.\n     *\n     * @param container\n     */\n    bootstrap(container = createContainer()) {\n        // Clone all providers in the container\n        this.addProviders(container);\n        // Resolve all configuration\n        this.resolveConfiguration();\n        // allow mocking or changing provider instance before loading injector\n        this.resolveImportsProviders();\n        return this;\n    }\n    /**\n     * Load injector from a given module\n     * @param rootModule\n     */\n    loadModule(rootModule) {\n        this.settings.routes = this.settings.routes.concat(resolveControllers(this.settings));\n        const container = createContainer();\n        container.delete(rootModule);\n        container.addProvider(rootModule, {\n            type: \"server:module\",\n            scope: ProviderScope.SINGLETON\n        });\n        return this.load(container);\n    }\n    /**\n     * Build all providers from given container (or GlobalProviders) and emit `$onInit` event.\n     *\n     * @param container\n     */\n    async load(container = createContainer()) {\n        this.bootstrap(container);\n        // build async and sync provider\n        await this.loadAsync();\n        // load sync provider\n        this.loadSync();\n        await this.emit(\"$beforeInit\");\n        await this.emit(\"$onInit\");\n    }\n    /**\n     * Load all configurations registered on providers\n     */\n    resolveConfiguration() {\n        if (this.resolvedConfiguration) {\n            return;\n        }\n        const mergedConfiguration = new Map();\n        super.forEach((provider) => {\n            if (provider.configuration && provider.type !== \"server:module\") {\n                Object.entries(provider.configuration).forEach(([key, value]) => {\n                    if (![\"resolvers\", \"mount\", \"imports\"].includes(key)) {\n                        value = mergedConfiguration.has(key) ? deepMerge(mergedConfiguration.get(key), value) : deepClone(value);\n                        mergedConfiguration.set(key, value);\n                    }\n                });\n            }\n            if (provider.resolvers) {\n                this.settings.resolvers = this.settings.resolvers.concat(provider.resolvers);\n            }\n        });\n        mergedConfiguration.forEach((value, key) => {\n            this.settings.set(key, deepMerge(value, this.settings.get(key)));\n        });\n        this.resolvedConfiguration = true;\n    }\n    /**\n     *\n     * @param instance\n     * @param locals\n     * @param options\n     */\n    bindInjectableProperties(instance, locals, options) {\n        const properties = ancestorsOf(classOf(instance)).reduce((properties, target) => {\n            const store = Store.from(target);\n            return {\n                ...properties,\n                ...(store.get(INJECTABLE_PROP) || {})\n            };\n        }, {});\n        Object.values(properties).forEach((definition) => {\n            switch (definition.bindingType) {\n                case InjectablePropertyType.PROPERTY:\n                    this.bindProperty(instance, definition, locals, options);\n                    break;\n                case InjectablePropertyType.CONSTANT:\n                    this.bindConstant(instance, definition);\n                    break;\n                case InjectablePropertyType.VALUE:\n                    this.bindValue(instance, definition);\n                    break;\n                case InjectablePropertyType.INTERCEPTOR:\n                    this.bindInterceptor(instance, definition);\n                    break;\n            }\n        });\n    }\n    /**\n     * Create an injectable property.\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     * @param resolver\n     * @param options\n     * @param locals\n     * @param invokeOptions\n     */\n    bindProperty(instance, { propertyKey, resolver, options = {} }, locals, invokeOptions) {\n        let get;\n        get = resolver(this, locals, { ...invokeOptions, options });\n        catchError(() => Reflect.deleteProperty(instance, propertyKey));\n        catchError(() => Reflect.defineProperty(instance, propertyKey, {\n            get,\n            enumerable: true,\n            configurable: true\n        }));\n    }\n    /**\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     */\n    bindValue(instance, { propertyKey, expression, defaultValue }) {\n        const descriptor = {\n            get: () => this.settings.get(expression) || defaultValue,\n            set: (value) => this.settings.set(expression, value),\n            enumerable: true,\n            configurable: true\n        };\n        catchError(() => Reflect.deleteProperty(instance, propertyKey));\n        catchError(() => Reflect.defineProperty(instance, propertyKey, descriptor));\n    }\n    /**\n     *\n     * @param instance\n     * @param {string} propertyKey\n     * @param {any} useType\n     */\n    bindConstant(instance, { propertyKey, expression, defaultValue }) {\n        let bean;\n        const get = () => {\n            if (bean !== undefined) {\n                return bean;\n            }\n            const value = this.settings.get(expression, defaultValue);\n            bean = Object.freeze(deepClone(value));\n            return bean;\n        };\n        const descriptor = {\n            get,\n            enumerable: true,\n            configurable: true\n        };\n        catchError(() => Reflect.deleteProperty(instance, propertyKey));\n        catchError(() => Object.defineProperty(instance, propertyKey, descriptor));\n    }\n    /**\n     *\n     * @param instance\n     * @param propertyKey\n     * @param useType\n     * @param options\n     */\n    bindInterceptor(instance, { propertyKey, useType, options }) {\n        const target = classOf(instance);\n        const originalMethod = instance[propertyKey];\n        instance[propertyKey] = (...args) => {\n            const next = (err) => {\n                if (!err) {\n                    return originalMethod.apply(instance, args);\n                }\n                throw err;\n            };\n            const context = {\n                target,\n                propertyKey,\n                args,\n                options,\n                next\n            };\n            const interceptor = this.get(useType);\n            return interceptor.intercept({\n                ...context,\n                options\n            }, next);\n        };\n    }\n    async lazyInvoke(token) {\n        let instance = this.getInstance(token);\n        if (!instance) {\n            instance = await this.invoke(token);\n            if (isFunction(instance?.$onInit)) {\n                await instance.$onInit();\n            }\n        }\n        return instance;\n    }\n    /**\n     * Emit an event to all service. See service [lifecycle hooks](/docs/services.md#lifecycle-hooks).\n     * @param eventName The event name to emit at all services.\n     * @param args List of the parameters to give to each service.\n     * @returns {Promise<any[]>} A list of promises.\n     */\n    emit(eventName, ...args) {\n        return this.#hooks.asyncEmit(eventName, args);\n    }\n    /**\n     * @param eventName\n     * @param value\n     * @param args\n     */\n    alter(eventName, value, ...args) {\n        return this.#hooks.alter(eventName, value, args);\n    }\n    /**\n     * @param eventName\n     * @param value\n     * @param args\n     */\n    alterAsync(eventName, value, ...args) {\n        return this.#hooks.asyncAlter(eventName, value, args);\n    }\n    async destroy() {\n        await this.emit(\"$onDestroy\");\n        globalInjector = undefined;\n    }\n    ensureProvider(token, force = false) {\n        if (!this.hasProvider(token) && (GlobalProviders.has(token) || force)) {\n            this.addProvider(token);\n        }\n        return this.getProvider(token);\n    }\n    getInstance(token) {\n        return this.#cache.get(token);\n    }\n    /**\n     * Invoke a class method and inject service.\n     *\n     * #### IInjectableMethod options\n     *\n     * * **target**: Optional. The class instance.\n     * * **methodName**: `string` Optional. The method name.\n     * * **designParamTypes**: `any[]` Optional. List of injectable types.\n     * * **locals**: `Map<Function, any>` Optional. If preset then any argument Class are read from this object first, before the `InjectorService` is consulted.\n     *\n     * #### Example\n     *\n     * @param target\n     * @param locals\n     * @param options\n     * @private\n     */\n    resolve(target, locals = new LocalsContainer(), options = {}) {\n        const resolvedOpts = this.mapInvokeOptions(target, locals, options);\n        if (!resolvedOpts) {\n            return undefined;\n        }\n        const { token, deps, construct, imports, provider } = resolvedOpts;\n        if (provider) {\n            GlobalProviders.onInvoke(provider, locals, { ...resolvedOpts, injector: this });\n        }\n        let instance;\n        let currentDependency = false;\n        try {\n            const invokeDependency = (parent) => (token, index) => {\n                currentDependency = { token, index, deps };\n                if (token !== DI_PARAM_OPTIONS) {\n                    const options = provider?.store?.get(`${DI_PARAM_OPTIONS}:${index}`);\n                    locals.set(DI_PARAM_OPTIONS, options || {});\n                }\n                if (isArray(token)) {\n                    return this.getMany(token[0], locals, options);\n                }\n                return isInheritedFrom(token, Provider, 1) ? provider : this.invoke(token, locals, { parent });\n            };\n            // Invoke manually imported providers\n            imports.forEach(invokeDependency());\n            // Inject dependencies\n            const services = deps.map(invokeDependency(token));\n            currentDependency = false;\n            instance = construct(services);\n        }\n        catch (error) {\n            InjectionError.throwInjectorError(token, currentDependency, error);\n        }\n        if (instance === undefined) {\n            throw new InjectionError(token, `Unable to create new instance from undefined value. Check your provider declaration for ${nameOf(token)}`);\n        }\n        if (instance && isClass(classOf(instance))) {\n            this.bindInjectableProperties(instance, locals, options);\n        }\n        return instance;\n    }\n    resolveImportsProviders() {\n        this.settings.imports = this.settings.imports\n            ?.filter((meta) => meta.token !== InjectorService_1)\n            .map((meta) => {\n            if (\"token\" in meta) {\n                const { token, ...props } = meta;\n                const provider = this.ensureProvider(token, true);\n                if (provider) {\n                    provider.useValue = undefined;\n                    provider.useAsyncFactory = undefined;\n                    provider.useFactory = undefined;\n                    if (\"useClass\" in props) {\n                        provider.useClass = props.useClass;\n                        return;\n                    }\n                    if (\"useFactory\" in props) {\n                        provider.useFactory = props.useFactory;\n                        return;\n                    }\n                    if (\"useAsyncFactory\" in props) {\n                        provider.useAsyncFactory = props.useAsyncFactory;\n                        return;\n                    }\n                    if (\"use\" in props) {\n                        provider.useValue = props.use;\n                        return;\n                    }\n                }\n            }\n            return meta;\n        })\n            .filter(Boolean);\n    }\n    /**\n     * Create options to invoke a provider or class.\n     * @param token\n     * @param locals\n     * @param options\n     */\n    mapInvokeOptions(token, locals, options) {\n        let imports = options.imports;\n        let deps = options.deps;\n        let scope = options.scope;\n        let construct;\n        if (!token || token === Object) {\n            throw new UndefinedTokenError();\n        }\n        let provider;\n        if (!this.hasProvider(token)) {\n            provider = new Provider(token);\n            this.resolvers.forEach((resolver) => {\n                const result = resolver.get(token, locals.get(DI_PARAM_OPTIONS));\n                if (result !== undefined) {\n                    provider.useFactory = () => result;\n                }\n            });\n        }\n        else {\n            provider = this.getProvider(token);\n        }\n        scope = scope || this.scopeOf(provider);\n        deps = deps || provider.deps;\n        imports = imports || provider.imports;\n        if (provider.useValue !== undefined) {\n            construct = () => (isFunction(provider.useValue) ? provider.useValue() : provider.useValue);\n        }\n        else if (provider.useFactory) {\n            construct = (deps) => provider.useFactory(...deps);\n        }\n        else if (provider.useAsyncFactory) {\n            construct = async (deps) => {\n                deps = await Promise.all(deps);\n                return provider.useAsyncFactory(...deps);\n            };\n        }\n        else if (provider.useClass) {\n            // useClass\n            deps = deps || getConstructorDependencies(provider.useClass);\n            construct = (deps) => new provider.useClass(...deps);\n        }\n        else {\n            return false;\n        }\n        return {\n            token,\n            scope: scope || Store.from(token).get(\"scope\") || ProviderScope.SINGLETON,\n            deps: deps || [],\n            imports: imports || [],\n            construct,\n            provider\n        };\n    }\n    registerHooks(provider, instance) {\n        if (provider.hooks) {\n            Object.entries(provider.hooks).forEach(([event, cb]) => {\n                const callback = (...args) => cb(this.get(provider.token) || instance, ...args);\n                this.#hooks.on(event, callback);\n            });\n        }\n    }\n};\nInjectorService = InjectorService_1 = __decorate([\n    Injectable({\n        scope: ProviderScope.SINGLETON\n    }),\n    __metadata(\"design:paramtypes\", [])\n], InjectorService);\nexport { InjectorService };\n","import { LocalsContainer } from \"../domain/LocalsContainer.js\";\nimport { InjectorService } from \"../services/InjectorService.js\";\nexport function AutoInjectable() {\n    return (constr) => {\n        return class AutoInjectable extends constr {\n            constructor(...args) {\n                const locals = new LocalsContainer();\n                super(...InjectorService.resolveAutoInjectableArgs(constr, locals, args));\n                InjectorService.bind(this, locals);\n            }\n        };\n    };\n}\n","import { Store } from \"@tsed/core\";\nimport { INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { InjectablePropertyType } from \"../domain/InjectablePropertyType.js\";\n/**\n * Return value from Configuration.\n *\n * ## Example\n *\n * ```typescript\n * import {Env} from \"@tsed/core\";\n * import {Constant, Value} from \"@tsed/di\";\n *\n * export class MyClass {\n *\n *    @Constant(\"env\")\n *    env: Env;\n *\n *    @Value(\"swagger.path\")\n *    swaggerPath: string;\n *\n *    @Value(\"swagger.path\", \"defaultValue\")\n *    swaggerPath: string;\n *\n *    constructor() {\n *       console.log(this.swaggerPath) // undefined. Not available on constructor\n *    }\n *\n *    $onInit() {\n *      console.log(this.swaggerPath)  // something\n *    }\n * }\n * ```\n *\n * @param {string} expression\n * @param defaultValue\n * @returns {(targetClass: any, attributeName: string) => any}\n * @decorator\n */\nexport function Constant(expression, defaultValue) {\n    return (target, propertyKey) => {\n        Store.from(target).merge(INJECTABLE_PROP, {\n            [propertyKey]: {\n                bindingType: InjectablePropertyType.CONSTANT,\n                propertyKey,\n                expression,\n                defaultValue\n            }\n        });\n    };\n}\n","import { isArrayOrArrayClass, useDecorators } from \"@tsed/core\";\nimport { Children, Path } from \"@tsed/schema\";\nimport { registerController } from \"../registries/ProviderRegistry.js\";\nfunction mapOptions(options) {\n    if (typeof options === \"string\" || options instanceof RegExp || isArrayOrArrayClass(options)) {\n        return {\n            path: options\n        };\n    }\n    return options;\n}\n/**\n * Declare a new controller with his Rest path. His methods annotated will be collected to build the routing list.\n * This routing listing will be built with the `express.Router` object.\n *\n * ::: tip\n * See [Controllers](/docs/controllers.md) section for more details\n * :::\n *\n * ```typescript\n *  @Controller(\"/calendars\")\n *  export provide CalendarCtrl {\n *\n *    @Get(\"/:id\")\n *    public get(\n *      @Req() request: Req,\n *      @Res() response: Res,\n *      @Next() next: Next\n *    ): void {\n *\n *    }\n *  }\n * ```\n *\n * @param options\n * @controller\n * @decorator\n * @classDecorator\n */\nexport function Controller(options) {\n    const { children = [], path, ...opts } = mapOptions(options);\n    return useDecorators((target) => {\n        registerController({\n            provide: target,\n            ...opts\n        });\n    }, path && Path(path), Children(...children));\n}\n","import { decorateMethodsOf, decoratorTypeOf, DecoratorTypes, Store } from \"@tsed/core\";\nimport { INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { InjectablePropertyType } from \"../domain/InjectablePropertyType.js\";\n/**\n * Attaches interceptor to method call and executes the before and after methods\n *\n * @param interceptor\n * @param options\n * @decorator\n */\nexport function Intercept(interceptor, options) {\n    return (...args) => {\n        const [target, propertyKey, descriptor] = args;\n        const type = decoratorTypeOf(args);\n        switch (type) {\n            case DecoratorTypes.CLASS:\n                decorateMethodsOf(target, Intercept(interceptor, options));\n                break;\n            case DecoratorTypes.METHOD:\n                Store.from(target).merge(INJECTABLE_PROP, {\n                    [propertyKey]: {\n                        options,\n                        propertyKey,\n                        useType: interceptor,\n                        bindingType: InjectablePropertyType.INTERCEPTOR\n                    }\n                });\n                return descriptor;\n        }\n    };\n}\n","import { ProviderType } from \"../domain/ProviderType.js\";\nimport { Injectable } from \"./injectable.js\";\n/**\n * The decorators `@Service()` declare a new service can be injected in other service or controller on there `constructor`.\n * All services annotated with `@Service()` are constructed one time.\n *\n * > `@Service()` use the `reflect-metadata` to collect and inject service on controllers or other services.\n *\n * @returns {Function}\n * @decorator\n */\nexport function Interceptor() {\n    return Injectable({\n        type: ProviderType.INTERCEPTOR\n    });\n}\n","import { importPackage } from \"@tsed/core\";\nimport { injectProperty } from \"./inject.js\";\n/**\n * Lazy load a provider from his package and invoke only when the provider is used\n *\n * ```typescript\n * import type {PlatformException} from \"@tsed/platform-exceptions\";\n *\n * @Injectable()\n * export class MyService {\n *   @LazyInject(\"PlatformException\", () => import(\"@tsed/platform-exceptions\"))\n *   exceptions: Promise<PlatformException>;\n * }\n * ```\n *\n * @param key\n * @param packageName\n * @param resolver\n * @param optional\n * @returns {Function}\n * @decorator\n */\nexport function LazyInject(key, resolver, { optional = false, packageName = resolver.toString() } = {}) {\n    return (target, propertyKey) => {\n        let bean, token;\n        injectProperty(target, propertyKey, {\n            resolver(injector) {\n                return async () => {\n                    if (!token || !bean) {\n                        const exports = await importPackage(packageName, resolver, optional);\n                        token = exports[key];\n                        if (!token) {\n                            if (!optional) {\n                                throw new Error(`Unable to lazy load the \"${key}\". The token isn\\'t a valid token provider.`);\n                            }\n                        }\n                        bean = token ? await injector.lazyInvoke(token) : {};\n                    }\n                    return bean;\n                };\n            }\n        });\n    };\n}\n/**\n * Optionally Lazy load a provider from his package and invoke only when the provider is used\n *\n * ```typescript\n * import type {PlatformException} from \"@tsed/platform-exceptions\";\n *\n * @Injectable()\n * export class MyService {\n *   @OptionalLazyInject(\"@tsed/platform-exceptions\")\n *   exceptions: Promise<PlatformException>;\n * }\n * ```\n *\n * @param key\n * @param resolver\n * @returns {Function}\n * @decorator\n */\nexport function OptionalLazyInject(key, resolver) {\n    return LazyInject(key, resolver, { optional: true });\n}\n","import { useDecorators } from \"@tsed/core\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\nimport { Configuration } from \"./configuration.js\";\nimport { Injectable } from \"./injectable.js\";\nimport { ProviderType } from \"../domain/ProviderType.js\";\n/**\n * Declare a new Ts.ED module\n *\n * ## Options\n * - imports: List of Provider which must be built by injector before invoking the module\n * - resolvers: List of external DI must be used to resolve unknown provider\n * - deps: List of provider must be injected to the module constructor (explicit declaration)\n *\n * @param options\n * @decorator\n */\nexport function Module(options = {}) {\n    const { scopes, imports, resolvers, deps, scope, ...configuration } = options;\n    return useDecorators(Configuration(configuration), Injectable({\n        type: ProviderType.MODULE,\n        scope: ProviderScope.SINGLETON,\n        imports,\n        deps,\n        injectable: false,\n        resolvers\n    }));\n}\n","import { StoreSet } from \"@tsed/core\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\n/**\n *\n * @param {\"request\" | \"singleton\" | ProviderScope} scope\n * @returns {Function}\n * @constructor\n */\nexport function Scope(scope = ProviderScope.REQUEST) {\n    return StoreSet(\"scope\", scope);\n}\n","import { classOf } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS } from \"../constants/constants.js\";\nimport { ProviderScope } from \"../domain/ProviderScope.js\";\nimport { Inject } from \"./inject.js\";\nimport { Scope } from \"./scope.js\";\n/**\n * Get instance options. This options depending on his invocation context.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @param target\n * @param propertyKey\n * @param index\n * @decorator\n */\nexport function Opts(target, propertyKey, index) {\n    Scope(ProviderScope.INSTANCE)(classOf(target));\n    Inject(DI_PARAM_OPTIONS)(target, propertyKey, index);\n}\n","import { GlobalProviders } from \"../registries/GlobalProviders.js\";\n/**\n * Override a provider which is already registered in ProviderRegistry.\n * @returns {Function}\n * @decorators\n * @param originalProvider\n */\nexport function OverrideProvider(originalProvider) {\n    return (target) => {\n        GlobalProviders.get(originalProvider).useClass = target;\n    };\n}\n","import { Injectable } from \"./injectable.js\";\n/**\n * The decorators `@Service()` declare a new service can be injected in other service or controller on there `constructor`.\n * All services annotated with `@Service()` are constructed one time.\n *\n * > `@Service()` use the `reflect-metadata` to collect and inject service on controllers or other services.\n *\n * @returns {Function}\n * @decorator\n */\nexport function Service() {\n    return Injectable();\n}\n","import { decoratorTypeOf, DecoratorTypes, Store, UnsupportedDecoratorType } from \"@tsed/core\";\nimport { DI_PARAM_OPTIONS, INJECTABLE_PROP } from \"../constants/constants.js\";\n/**\n * Add options to invoke the Service.\n *\n * ```typescript\n * import {Injectable, Opts, UseOpts} from \"@tsed/di\";\n *\n * @Injectable()\n * class MyConfigurableService {\n *   source: string;\n *   constructor(@Opts options: any = {}) {\n *      console.log(\"Hello \", options.source); // log: Hello Service1 then Hello Service2\n *\n *      this.source = options.source;\n *   }\n * }\n *\n * @Injectable()\n * class MyService1 {\n *   constructor(@UseOpts({source: 'Service1'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service1\n *   }\n * }\n *\n * @Injectable()\n * class MyService2 {\n *   constructor(@UseOpts({source: 'Service2'}) service: MyConfigurableService) {\n *     console.log(service.source) // log: Service2\n *   }\n * }\n * ```\n *\n * ::: warning\n * Using @@Opts@@ decorator on a constructor parameter change the Scope of the provider to `ProviderScope.INSTANCE`.\n * :::\n *\n * @returns {Function}\n * @decorator\n * @param options\n */\nexport function UseOpts(options) {\n    return (target, propertyKey, index) => {\n        const bindingType = decoratorTypeOf([target, propertyKey, index]);\n        switch (bindingType) {\n            case DecoratorTypes.PARAM_CTOR:\n                Store.from(target).merge(`${DI_PARAM_OPTIONS}:${index}`, options);\n                break;\n            case DecoratorTypes.PROP:\n                Store.from(target).merge(INJECTABLE_PROP, {\n                    [propertyKey]: {\n                        options\n                    }\n                });\n                break;\n            default:\n                throw new UnsupportedDecoratorType(UseOpts, [target, propertyKey, index]);\n        }\n    };\n}\n","import { Store } from \"@tsed/core\";\nimport { INJECTABLE_PROP } from \"../constants/constants.js\";\nimport { InjectablePropertyType } from \"../domain/InjectablePropertyType.js\";\n/**\n * Return value from Configuration.\n *\n * ## Example\n *\n * ```typescript\n * import {Env} from \"@tsed/core\";\n * import {Constant, Value} from \"@tsed/di\";\n *\n * export class MyClass {\n *\n *    @Constant(\"env\")\n *    env: Env;\n *\n *    @Value(\"swagger.path\")\n *    swaggerPath: string;\n *\n *    @Value(\"swagger.path\", \"defaultValue\")\n *    swaggerPath: string;\n *\n *    constructor() {\n *       console.log(this.swaggerPath) // undefined. Not available on constructor\n *    }\n *\n *    $onInit() {\n *      console.log(this.swaggerPath)  // something\n *    }\n * }\n * ```\n *\n * @param expression\n * @param defaultValue\n * @returns {(targetClass: any, attributeName: string) => any}\n * @decorator\n */\nexport function Value(expression, defaultValue) {\n    return (target, propertyKey) => {\n        Store.from(target).merge(INJECTABLE_PROP, {\n            [propertyKey]: {\n                bindingType: InjectablePropertyType.VALUE,\n                propertyKey,\n                expression,\n                defaultValue\n            }\n        });\n    };\n}\n","import { Provider } from \"./Provider.js\";\nimport { ProviderType } from \"./ProviderType.js\";\nexport class ControllerProvider extends Provider {\n    constructor(provide, options = {}) {\n        super(provide, options);\n        this.type = ProviderType.CONTROLLER;\n    }\n    /**\n     *\n     * @returns {any[]}\n     */\n    get middlewares() {\n        return Object.assign({\n            use: [],\n            useAfter: [],\n            useBefore: []\n        }, this.store.get(\"middlewares\", {}));\n    }\n    /**\n     *\n     * @param middlewares\n     */\n    set middlewares(middlewares) {\n        const mdlwrs = this.middlewares;\n        const concat = (key, a, b) => (a[key] = a[key].concat(b[key]));\n        Object.keys(middlewares).forEach((key) => {\n            concat(key, mdlwrs, middlewares);\n        });\n        this.store.set(\"middlewares\", mdlwrs);\n    }\n}\n","import { registerProvider } from \"../registries/ProviderRegistry.js\";\nimport { InjectorService } from \"./InjectorService.js\";\nexport const LOGGER = Symbol.for(\"LOGGER\");\nregisterProvider({\n    provide: LOGGER,\n    deps: [InjectorService],\n    useFactory(injector) {\n        return injector.logger;\n    }\n});\n","import { Store } from \"@tsed/core\";\nexport function mergeMount(m1 = {}, m2 = {}) {\n    return Object.entries(m2).reduce((mount, [key, controllers]) => {\n        return {\n            ...mount,\n            [key]: (mount[key] || []).concat(controllers)\n        };\n    }, m1);\n}\nexport function getConfiguration(module, configuration = {}) {\n    const store = Store.from(module).get(\"configuration\") || {};\n    return {\n        ...store,\n        ...configuration,\n        mount: mergeMount(store.mount, configuration.mount)\n    };\n}\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__803__","__WEBPACK_EXTERNAL_MODULE__953__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","INJECTABLE_PROP","DI_PARAMS","DI_PARAM_OPTIONS","ProviderScope","ProviderType","LocalsContainer","Map","constructor","super","arguments","this","hooks","Hooks","async","asyncEmit","create","SuppressedError","InvalidPropertyTokenError","Error","target","propertyKey","nameOf","classOf","name","getConstructorDependencies","Metadata","setConstructorDependencies","deps","injectProperty","options","Store","merge","bindingType","DecoratorTypes","Inject","token","onGet","bean","descriptor","decoratorTypeOf","paramTypes","type","Array","useType","String","resolver","injector","locals","invokeOptions","originalType","set","getMany","delete","forEach","instance","index","isPromise","then","result","invoke","UnsupportedDecoratorType","Configuration","configuration","args","StoreSet","Provider","PROVIDER","provide","useClass","assign","_provide","getClassOrSymbol","_tokenStore","_store","_useClass","isClass","methodsOf","reduce","startsWith","className","store","path","scope","isAsync","SINGLETON","children","useAsyncFactory","clone","hasChildren","length","hasParent","toString","useFactory","useValue","filter","Boolean","join","GlobalProviderRegistry","has","metadata","meta","createIfNotExists","keys","createRegistry","model","defaultOptions","getRegistrySettings","onInvoke","provider","settings","createRegisterFn","item","GlobalProviders","registerProvider","CONTROLLER","registerValue","VALUE","registerController","Injectable","Container","add","addProvider","hasProvider","setProvider","getProvider","getProviders","types","concat","providers","_","includes","addProviders","container","InjectablePropertyType","colorIfAllowed","colorFn","text","process","env","NO_COLOR","colors","red","yellow","green","InjectionError","origin","isString","tokens","message","stack","originMessage","tokensMessage","map","static","currentDependency","error","erroredArg","getConstructorArgNames","arg","signature","indexOf","repeat","drawline","printDependencyInjectionError","UndefinedTokenError","createContainer","rootModule","entries","lookupProperties","getTokens","config","isArray","list","route","resolveRecursively","MODULE","flatMap","resolveControllers","property","DIConfiguration","initialProps","default","scopes","resolvers","imports","routes","logger","proxyDelegation","ownKeys","version","v","rootDir","getRaw","debug","level","callbackfn","thisArg","Set","from","Reflect","setRaw","setValue","defaultValue","resolve","replace","getValue","InjectorService_1","globalInjector","InjectorService","console","resolvedConfiguration","Math","max","i","push","parent","bindInjectableProperties","scopeOf","toArray","values","getInstance","alias","rebuild","ensureProvider","registerHooks","REQUEST","$onDestroy","on","loadSync","bootstrap","resolveConfiguration","resolveImportsProviders","loadModule","load","loadAsync","emit","mergedConfiguration","deepMerge","deepClone","properties","ancestorsOf","PROPERTY","bindProperty","CONSTANT","bindConstant","bindValue","INTERCEPTOR","bindInterceptor","catchError","deleteProperty","configurable","expression","freeze","originalMethod","next","err","apply","context","intercept","isFunction","$onInit","eventName","alter","alterAsync","asyncAlter","force","resolvedOpts","mapInvokeOptions","construct","invokeDependency","isInheritedFrom","services","throwInjectorError","props","use","Promise","all","event","cb","AutoInjectable","constr","resolveAutoInjectableArgs","bind","Constant","decorators","desc","c","getOwnPropertyDescriptor","decorate","__decorate","metadataKey","metadataValue","__metadata","Controller","opts","RegExp","isArrayOrArrayClass","mapOptions","useDecorators","Path","Children","Intercept","interceptor","decorateMethodsOf","Interceptor","LazyInject","optional","packageName","importPackage","lazyInvoke","OptionalLazyInject","Module","injectable","Scope","Opts","INSTANCE","OverrideProvider","originalProvider","Service","UseOpts","Value","ControllerProvider","middlewares","useAfter","useBefore","mdlwrs","a","b","LOGGER","for","mergeMount","m1","m2","mount","controllers","getConfiguration"],"sourceRoot":""}