!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@tsed/core"),require("@tsed/schema")):"function"==typeof define&&define.amd?define(["@tsed/core","@tsed/schema"],t):"object"==typeof exports?exports["@tsed/di"]=t(require("@tsed/core"),require("@tsed/schema")):e["@tsed/di"]=t(e["@tsed/core"],e["@tsed/schema"])}(self,((e,t)=>(()=>{"use strict";var r={803:t=>{t.exports=e},953:e=>{e.exports=t}},s={};function o(e){var t=s[e];if(void 0!==t)return t.exports;var n=s[e]={exports:{}};return r[e](n,n.exports,o),n.exports}o.d=(e,t)=>{for(var r in t)o.o(t,r)&&!o.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{o.r(n),o.d(n,{AutoInjectable:()=>V,Configuration:()=>g,Constant:()=>_,Container:()=>k,Controller:()=>$,ControllerProvider:()=>X,DIConfiguration:()=>D,DI_PARAMS:()=>t,DI_PARAM_OPTIONS:()=>r,GlobalProviderRegistry:()=>y,GlobalProviders:()=>v,INJECTABLE_PROP:()=>e,Inject:()=>d,Injectable:()=>b,InjectablePropertyType:()=>P,InjectionError:()=>C,InjectorService:()=>x,Intercept:()=>U,Interceptor:()=>G,InvalidPropertyTokenError:()=>u,LOGGER:()=>Z,LazyInject:()=>K,LocalsContainer:()=>c,Module:()=>q,OptionalLazyInject:()=>H,Opts:()=>B,OverrideProvider:()=>J,Provider:()=>f,ProviderScope:()=>s,ProviderType:()=>i,Scope:()=>z,Service:()=>Q,UndefinedTokenError:()=>I,UseOpts:()=>Y,Value:()=>W,colors:()=>T,createContainer:()=>w,getConfiguration:()=>te,getConstructorDependencies:()=>h,getTokens:()=>A,injectProperty:()=>p,mergeMount:()=>ee,registerController:()=>E,registerProvider:()=>m,registerValue:()=>O,resolveControllers:()=>N,setConstructorDependencies:()=>l});const e="DI:INJECTABLE_PROP",t="DI:PARAMS",r="DI:PARAM:OPTIONS";var s,i,a=o(803);class c extends Map{constructor(){super(...arguments),this.hooks=new a.Hooks}async destroy(){await this.hooks.asyncEmit("$onDestroy")}}Object.create,Object.create,"function"==typeof SuppressedError&&SuppressedError;class u extends Error{constructor(e,t){super(`Object isn't a valid token. Please check the token set on ${(0,a.nameOf)((0,a.classOf)(e))}.${t}.\n- Check that it is not a circular reference.\n- Check that the token (class or symbol) exists`),this.name="INVALID_TOKEN_ERROR"}}function h(e,t){return a.Metadata.getOwn("override:ctor:design:paramtypes",e,t)||[...a.Metadata.getParamTypes(e,t)]||[]}function l(e,t){a.Metadata.set("override:ctor:design:paramtypes",t,e)}function p(t,r,s){a.Store.from(t).merge(e,{[r]:{bindingType:a.DecoratorTypes.PROP,propertyKey:r,...s}})}function d(e,t=(e=>e)){return(s,o,n)=>{switch((0,a.decoratorTypeOf)([s,o,n])){case a.DecoratorTypes.PARAM_CTOR:if(e){const t=h(s,o),r=t[n];t[n]=r===Array?[e]:e,a.Metadata.setParamTypes(s,o,t),l(s,t)}break;case a.DecoratorTypes.PROP:const i=e||a.Metadata.getType(s,o);if(i===Object)throw new u(s,String(o));p(s,String(o),{resolver(n,c,{options:u,...h}){const l=a.Metadata.getType(s,o);if(c.set(r,{...u}),l===Array){let s;return s||(s=n.getMany(e,c,h),c.delete(r)),s.forEach(((e,t)=>{(0,a.isPromise)(s)&&e.then((e=>{s[t]=e}))})),()=>t(s)}let p;return p||(p=n.invoke(i,c,h),c.delete(r)),(0,a.isPromise)(p)&&p.then((e=>{p=e})),()=>t(p)}});break;default:throw new a.UnsupportedDecoratorType(d,[s,o,n])}}}function g(e={}){return(...t)=>{switch((0,a.decoratorTypeOf)(t)){case a.DecoratorTypes.CLASS:(0,a.StoreSet)("configuration",e)(t[0]);break;default:case a.DecoratorTypes.PARAM_CTOR:return d(g)(t[0],t[1],t[2])}}}!function(e){e.SINGLETON="singleton",e.REQUEST="request",e.INSTANCE="instance"}(s||(s={})),function(e){e.VALUE="value",e.FACTORY="factory",e.SERVICE="service",e.PROVIDER="provider",e.MODULE="module",e.CONTROLLER="controller",e.INTERCEPTOR="interceptor",e.MIDDLEWARE="middleware"}(i||(i={}));class f{constructor(e,t={}){this.type=i.PROVIDER,this.provide=e,this.useClass=e,Object.assign(this,t)}get token(){return this._provide}get provide(){return this._provide}set provide(e){e&&(this._provide=(0,a.getClassOrSymbol)(e),this._tokenStore=this._store=a.Store.from(e))}get useClass(){return this._useClass}set useClass(e){(0,a.isClass)(e)&&(this._useClass=(0,a.classOf)(e),this._store=a.Store.from(e),this.hooks=(0,a.methodsOf)(this._useClass).reduce(((e,{propertyKey:t})=>String(t).startsWith("$")?{...e,[t]:(e,...r)=>e[t](...r)}:e),{}))}get className(){return this.name}get name(){return(0,a.nameOf)(this.provide)}get store(){return this._store}get path(){return this.store.get("path","/")}set path(e){this.store.set("path",e)}get scope(){return this.isAsync()?s.SINGLETON:this.get("scope")}set scope(e){this.store.set("scope",e)}get configuration(){return this.get("configuration")}set configuration(e){this.store.set("configuration",e)}get children(){return this.store.get("childrenControllers",[])}get(e){return this.store.get(e)||this._tokenStore.get(e)}isAsync(){return!!this.useAsyncFactory}clone(){return new((0,a.classOf)(this))(this._provide,this)}hasChildren(){return!!this.children.length}hasParent(){return!!this.store.get("parentController")}toString(){return["Token",this.name,this.useClass&&(0,a.nameOf)(this.useClass),this.useFactory&&"Factory",this.useValue&&"Value",this.useAsyncFactory&&"AsyncFactory"].filter(Boolean).join(":")}}class y extends Map{constructor(){super(...arguments),this.#e=new Map}#e;get(e){return super.get((0,a.getClassOrSymbol)(e))}has(e){return super.has((0,a.getClassOrSymbol)(e))}set(e,t){return super.set((0,a.getClassOrSymbol)(e),t),this}merge(e,t){const r=this.createIfNotExists(e,t);return Object.keys(t).forEach((e=>{r[e]=t[e]})),this.set(e,r),r}delete(e){return super.delete((0,a.getClassOrSymbol)(e))}createRegistry(e,t,r={}){const s=this.getRegistrySettings(e);return r=Object.assign(s,{...r,model:t}),this.#e.set(e,r),this}onInvoke(e,t,r){const s=this.#e.get(e.type);s?.onInvoke&&s.onInvoke(e,t,r)}getRegistrySettings(e){let t="provider";if("string"==typeof e)t=e;else{const r=this.get(e);r&&(t=r.type)}return this.#e.get(t)||{model:f}}createRegisterFn(e){return(t,r)=>{t=Object.assign({instance:r},t,{type:e}),this.merge(t.provide,t)}}createIfNotExists(e,t){const r=t.type||i.PROVIDER;if(!this.has(e)){const{model:s=f}=this.#e.get(r)||{},o=new s(e,t);this.set(e,o)}return this.get(e)}}const v=new y;function m(e){if(!e.provide)throw new Error("Provider.provide is required");return v.merge(e.provide,e)}v.createRegistry(i.CONTROLLER,f);const O=(e,t)=>{e.provide||(e={provide:e}),e=Object.assign({scope:s.SINGLETON,useValue:t},e,{type:i.VALUE}),v.merge(e.provide,e)},E=v.createRegisterFn(i.CONTROLLER);function b(e={}){return t=>{m({...e,...e.provide?{useClass:t}:{provide:t}})}}class k extends Map{add(e,t={}){const r=v.get(e)?.clone()||new f(e);return Object.assign(r,t),super.set(e,r)}addProvider(e,t={}){return this.add(e,t)}hasProvider(e){return super.has(e)}setProvider(e,t){return super.set(e,t)}getProvider(e){return super.get(e)}getProviders(e){const t=[].concat(e);return[...this].reduce(((r,[s,o])=>t.includes(o.type)||!e?[...r,o]:r),[])}addProviders(e){e.forEach((e=>{this.hasProvider(e.provide)||this.setProvider(e.provide,e.clone())}))}}var P;!function(e){e.METHOD="method",e.PROPERTY="property",e.CONSTANT="constant",e.VALUE="value",e.INTERCEPTOR="interceptor"}(P||(P={}));const R=e=>e=>(process.env.NO_COLOR,e),T={red:R(),yellow:R(),green:R()};class C extends Error{constructor(e,t){super((0,a.isString)(t)?t:""),this.name="INJECTION_ERROR",this.tokens=[],this.tokens=[e],t&&((0,a.isString)(t)?this.origin={message:t,stack:this.stack}:t.tokens?(this.tokens=this.tokens.concat(t.tokens),this.origin=t.origin):(this.origin=t,this.stack=t.stack));const r=this.origin?"\nOrigin: "+this.origin.message:"",s=this.tokens.map((e=>(0,a.nameOf)(e))).join(" > ");this.message=`Injection failed on ${s}${r}`}static throwInjectorError(e,t,r){throw t&&(0,a.isClass)(e)&&(r.message=function(e,t){let r="";const s=(0,a.getConstructorArgNames)(e).map(((e,s)=>(t.index===s&&(r=e,e=T.red(e)),`${e}: ${(0,a.nameOf)(t.deps[s])}`))).join(", "),o=(0,a.nameOf)(e)+"->constructor("+s+")",n=o.indexOf(r)-5;return"Unable to inject dependency. "+t.message+"\n\n"+o+"\n"+(n>-1?(e=>" ".repeat(e)+T.red("^"+"â€¾".repeat(r.length-1)))(n):"")}(e,{...t,message:r.message})),new C(e,r)}}class I extends Error{constructor(){super("Given token is undefined. Have you enabled emitDecoratorMetadata in your tsconfig.json or decorated your class with @Injectable, @Service, ... decorator ?"),this.name="UNDEFINED_TOKEN_ERROR"}}function w(e){const t=new k(v.entries());return e&&t.delete(e),t}const S=["mount","imports"];function A(e){return e?(0,a.isArray)(e)?e.filter(a.isClass).map((e=>({token:e}))):Object.keys(e).reduce(((t,r)=>[...t,...[].concat(e[r]).filter(a.isClass).map((e=>({route:r,token:e})))]),[]):[]}function j(e){return e.map((({token:e})=>v.get(e))).filter((e=>e?.type===i.MODULE&&e.configuration)).flatMap((e=>N(e.configuration)))}function N(e){const t=S.flatMap((t=>A(e[t])));return[...j(t),...t].filter((e=>!!e.route))}class D{constructor(e={}){return this.default=new Map,this.map=new Map,Object.entries({scopes:{},resolvers:[],imports:[],routes:[],logger:{},...e}).forEach((([e,t])=>{this.default.set(e,t)})),(0,a.proxyDelegation)(this,{ownKeys:e=>[...e.default.keys(),...e.map.keys()]})}get version(){return this.get("version")}set version(e){this.map.set("version",e)}get rootDir(){return this.get("rootDir")}set rootDir(e){this.map.set("rootDir",e)}get env(){return this.map.get("env")}set env(e){this.map.set("env",e)}get scopes(){return this.map.get("scopes")}set scopes(e){this.map.set("scopes",e)}get resolvers(){return this.getRaw("resolvers")}set resolvers(e){this.map.set("resolvers",e)}get imports(){return this.get("imports")}set imports(e){this.map.set("imports",e)}get routes(){return this.get("routes")}set routes(e){this.map.set("routes",e)}get logger(){return this.get("logger")}set logger(e){const t={...this.logger,...e};this.map.set("logger",t)}get debug(){return"debug"===this.logger.level}set debug(e){this.logger={...this.logger,level:e?"debug":"info"}}forEach(e,t){return new Set([...Array.from(this.default.keys()),...Array.from(this.map.keys())]).forEach((t=>{e(this.getRaw(t),t,this.map)}),t)}set(e,t){return"string"==typeof e?Reflect.has(this,e)?this[e]=t:this.setRaw(e,t):Object.entries(e).forEach((([e,t])=>{this.set(e,t)})),this}setRaw(e,t){return(0,a.setValue)(this.map,e,t),this}get(e,t){return this.getRaw(e,t)}resolve(e){return e.replace("${rootDir}",this.rootDir)}getRaw(e,t){const r=(0,a.getValue)(this.map,e);return void 0!==r?r:(0,a.getValue)(this.default,e,t)}}var M;let L,x=M=class extends k{#t;#r;constructor(){super(),this.settings=new D,this.logger=console,this.resolvedConfiguration=!1,this.#t=new c,this.#r=new a.Hooks,this.#t.set(M,this),L=this}get resolvers(){return this.settings.resolvers}get scopes(){return this.settings.scopes||{}}static resolveAutoInjectableArgs(e,t,r){if(!L)throw new Error("InjectorService instance is not created yet.");const s=h(e),o=[],n=Math.max(s.length,r.length);for(let i=0;i<n;i++)if(void 0!==r[i])o.push(r[i]);else{const r=s[i],n=(0,a.isArray)(r)?L.getMany(r[0],t,{parent:e}):L.invoke(r,t,{parent:e});o.push(n)}return o}static bind(e,t){L.bindInjectableProperties(e,t,{})}scopeOf(e){return e.scope||this.scopes[e.type]||s.SINGLETON}toArray(){return[...this.#t.values()]}get(e,t={}){const r=this.getInstance(e);if(void 0!==r)return r;if(!this.hasProvider(e))for(const r of this.resolvers){const s=r.get(e,t);if(void 0!==s)return s}}getMany(e,t,r){return this.getProviders(e).map((e=>this.invoke(e.token,t,r)))}has(e){return void 0!==this.#t.get(e)}alias(e,t){return this.#t.set(t,this.#t.get(e)),this}invoke(e,t,o={}){let n=t?t.get(e):void 0;if(void 0!==n)return n;if(e===g)return this.settings;if(n=o.rebuild?void 0:this.getInstance(e),null!=n)return n;if(e===r)return{};const i=this.ensureProvider(e),c=t=>{this.#t.set(e,t),i?.alias&&this.alias(e,i.alias)};if(!i||o.rebuild)return n=this.resolve(e,t,o),this.hasProvider(e)&&c(n),n;switch(n=this.resolve(e,t,o),this.scopeOf(i)){case s.SINGLETON:return i.hooks&&!o.rebuild&&this.registerHooks(i,n),i.isAsync()&&(0,a.isPromise)(n)?(c(n),n=n.then((e=>(c(e),e))),n):(c(n),n);case s.REQUEST:return t&&(t.set(e,n),i.hooks&&i.hooks.$onDestroy&&t.hooks.on("$onDestroy",((...e)=>i.hooks.$onDestroy(n,...e)))),n}return n}async loadAsync(){for(const[,e]of this)!this.has(e.token)&&e.isAsync()&&await this.invoke(e.token)}loadSync(){for(const[,e]of this)this.has(e.token)||this.scopeOf(e)!==s.SINGLETON||this.invoke(e.token)}bootstrap(e=w()){return this.addProviders(e),this.resolveConfiguration(),this.resolveImportsProviders(),this}loadModule(e){this.settings.routes=this.settings.routes.concat(N(this.settings));const t=w();return t.delete(e),t.addProvider(e,{type:"server:module",scope:s.SINGLETON}),this.load(t)}async load(e=w()){this.bootstrap(e),await this.loadAsync(),this.loadSync(),await this.emit("$beforeInit"),await this.emit("$onInit")}resolveConfiguration(){if(this.resolvedConfiguration)return;const e=new Map;super.forEach((t=>{t.configuration&&"server:module"!==t.type&&Object.entries(t.configuration).forEach((([t,r])=>{["resolvers","mount","imports"].includes(t)||(r=e.has(t)?(0,a.deepMerge)(e.get(t),r):(0,a.deepClone)(r),e.set(t,r))})),t.resolvers&&(this.settings.resolvers=this.settings.resolvers.concat(t.resolvers))})),e.forEach(((e,t)=>{this.settings.set(t,(0,a.deepMerge)(e,this.settings.get(t)))})),this.resolvedConfiguration=!0}bindInjectableProperties(t,r,s){const o=(0,a.ancestorsOf)((0,a.classOf)(t)).reduce(((t,r)=>({...t,...a.Store.from(r).get(e)||{}})),{});Object.values(o).forEach((e=>{switch(e.bindingType){case P.PROPERTY:this.bindProperty(t,e,r,s);break;case P.CONSTANT:this.bindConstant(t,e);break;case P.VALUE:this.bindValue(t,e);break;case P.INTERCEPTOR:this.bindInterceptor(t,e)}}))}bindProperty(e,{propertyKey:t,resolver:r,options:s={}},o,n){let i;i=r(this,o,{...n,options:s}),(0,a.catchError)((()=>Reflect.deleteProperty(e,t))),(0,a.catchError)((()=>Reflect.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0})))}bindValue(e,{propertyKey:t,expression:r,defaultValue:s}){const o={get:()=>this.settings.get(r)||s,set:e=>this.settings.set(r,e),enumerable:!0,configurable:!0};(0,a.catchError)((()=>Reflect.deleteProperty(e,t))),(0,a.catchError)((()=>Reflect.defineProperty(e,t,o)))}bindConstant(e,{propertyKey:t,expression:r,defaultValue:s}){let o;const n={get:()=>{if(void 0!==o)return o;const e=this.settings.get(r,s);return o=Object.freeze((0,a.deepClone)(e)),o},enumerable:!0,configurable:!0};(0,a.catchError)((()=>Reflect.deleteProperty(e,t))),(0,a.catchError)((()=>Object.defineProperty(e,t,n)))}bindInterceptor(e,{propertyKey:t,useType:r,options:s}){const o=(0,a.classOf)(e),n=e[t];e[t]=(...i)=>{const a=t=>{if(!t)return n.apply(e,i);throw t},c={target:o,propertyKey:t,args:i,options:s,next:a};return this.get(r).intercept({...c,options:s},a)}}async lazyInvoke(e){let t=this.getInstance(e);return t||(t=await this.invoke(e),(0,a.isFunction)(t?.$onInit)&&await t.$onInit()),t}emit(e,...t){return this.#r.asyncEmit(e,t)}alter(e,t,...r){return this.#r.alter(e,t,r)}alterAsync(e,t,...r){return this.#r.asyncAlter(e,t,r)}async destroy(){await this.emit("$onDestroy"),L=void 0}ensureProvider(e,t=!1){return this.hasProvider(e)||!v.has(e)&&!t||this.addProvider(e),this.getProvider(e)}getInstance(e){return this.#t.get(e)}resolve(e,t=new c,s={}){const o=this.mapInvokeOptions(e,t,s);if(!o)return;const{token:n,deps:i,construct:u,imports:h,provider:l}=o;let p;l&&v.onInvoke(l,t,{...o,injector:this});let d=!1;try{const e=e=>(o,n)=>{if(d={token:o,index:n,deps:i},o!==r){const e=l?.store?.get(`${r}:${n}`);t.set(r,e||{})}return(0,a.isArray)(o)?this.getMany(o[0],t,s):(0,a.isInheritedFrom)(o,f,1)?l:this.invoke(o,t,{parent:e})};h.forEach(e());const o=i.map(e(n));d=!1,p=u(o)}catch(e){C.throwInjectorError(n,d,e)}if(void 0===p)throw new C(n,`Unable to create new instance from undefined value. Check your provider declaration for ${(0,a.nameOf)(n)}`);return p&&(0,a.isClass)((0,a.classOf)(p))&&this.bindInjectableProperties(p,t,s),p}resolveImportsProviders(){this.settings.imports=this.settings.imports?.filter((e=>e.token!==M)).map((e=>{if("token"in e){const{token:t,...r}=e,s=this.ensureProvider(t,!0);if(s){if(s.useValue=void 0,s.useAsyncFactory=void 0,s.useFactory=void 0,"useClass"in r)return void(s.useClass=r.useClass);if("useFactory"in r)return void(s.useFactory=r.useFactory);if("useAsyncFactory"in r)return void(s.useAsyncFactory=r.useAsyncFactory);if("use"in r)return void(s.useValue=r.use)}}return e})).filter(Boolean)}mapInvokeOptions(e,t,o){let n,i,c=o.imports,u=o.deps,l=o.scope;if(!e||e===Object)throw new I;if(this.hasProvider(e)?i=this.getProvider(e):(i=new f(e),this.resolvers.forEach((s=>{const o=s.get(e,t.get(r));void 0!==o&&(i.useFactory=()=>o)}))),l=l||this.scopeOf(i),u=u||i.deps,c=c||i.imports,void 0!==i.useValue)n=()=>(0,a.isFunction)(i.useValue)?i.useValue():i.useValue;else if(i.useFactory)n=e=>i.useFactory(...e);else if(i.useAsyncFactory)n=async e=>(e=await Promise.all(e),i.useAsyncFactory(...e));else{if(!i.useClass)return!1;u=u||h(i.useClass),n=e=>new i.useClass(...e)}return{token:e,scope:l||a.Store.from(e).get("scope")||s.SINGLETON,deps:u||[],imports:c||[],construct:n,provider:i}}registerHooks(e,t){e.hooks&&Object.entries(e.hooks).forEach((([r,s])=>{this.#r.on(r,((...r)=>s(this.get(e.token)||t,...r)))}))}};function V(){return e=>class extends e{constructor(...t){const r=new c;super(...x.resolveAutoInjectableArgs(e,r,t)),x.bind(this,r)}}}function _(t,r){return(s,o)=>{a.Store.from(s).merge(e,{[o]:{bindingType:P.CONSTANT,propertyKey:o,expression:t,defaultValue:r}})}}x=M=function(e,t,r,s){var o,n=arguments.length,i=n<3?t:null===s?s=Object.getOwnPropertyDescriptor(t,r):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,t,r,s);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(i=(n<3?o(i):n>3?o(t,r,i):o(t,r))||i);return n>3&&i&&Object.defineProperty(t,r,i),i}([b({scope:s.SINGLETON}),function(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}("design:paramtypes",[])],x);var F=o(953);function $(e){const{children:t=[],path:r,...s}=function(e){return"string"==typeof e||e instanceof RegExp||(0,a.isArrayOrArrayClass)(e)?{path:e}:e}(e);return(0,a.useDecorators)((e=>{E({provide:e,...s})}),r&&(0,F.Path)(r),(0,F.Children)(...t))}function U(t,r){return(...s)=>{const[o,n,i]=s;switch((0,a.decoratorTypeOf)(s)){case a.DecoratorTypes.CLASS:(0,a.decorateMethodsOf)(o,U(t,r));break;case a.DecoratorTypes.METHOD:return a.Store.from(o).merge(e,{[n]:{options:r,propertyKey:n,useType:t,bindingType:P.INTERCEPTOR}}),i}}}function G(){return b({type:i.INTERCEPTOR})}function K(e,t,{optional:r=!1,packageName:s=t.toString()}={}){return(o,n)=>{let i,c;p(o,n,{resolver:o=>async()=>{if(!c||!i){const n=await(0,a.importPackage)(s,t,r);if(c=n[e],!c&&!r)throw new Error(`Unable to lazy load the "${e}". The token isn't a valid token provider.`);i=c?await o.lazyInvoke(c):{}}return i}})}}function H(e,t){return K(e,t,{optional:!0})}function q(e={}){const{scopes:t,imports:r,resolvers:o,deps:n,scope:c,...u}=e;return(0,a.useDecorators)(g(u),b({type:i.MODULE,scope:s.SINGLETON,imports:r,deps:n,injectable:!1,resolvers:o}))}function z(e=s.REQUEST){return(0,a.StoreSet)("scope",e)}function B(e,t,o){z(s.INSTANCE)((0,a.classOf)(e)),d(r)(e,t,o)}function J(e){return t=>{v.get(e).useClass=t}}function Q(){return b()}function Y(t){return(s,o,n)=>{switch((0,a.decoratorTypeOf)([s,o,n])){case a.DecoratorTypes.PARAM_CTOR:a.Store.from(s).merge(`${r}:${n}`,t);break;case a.DecoratorTypes.PROP:a.Store.from(s).merge(e,{[o]:{options:t}});break;default:throw new a.UnsupportedDecoratorType(Y,[s,o,n])}}}function W(t,r){return(s,o)=>{a.Store.from(s).merge(e,{[o]:{bindingType:P.VALUE,propertyKey:o,expression:t,defaultValue:r}})}}class X extends f{constructor(e,t={}){super(e,t),this.type=i.CONTROLLER}get middlewares(){return Object.assign({use:[],useAfter:[],useBefore:[]},this.store.get("middlewares",{}))}set middlewares(e){const t=this.middlewares;Object.keys(e).forEach((r=>{((e,t,r)=>{t[e]=t[e].concat(r[e])})(r,t,e)})),this.store.set("middlewares",t)}}const Z=Symbol.for("LOGGER");function ee(e={},t={}){return Object.entries(t).reduce(((e,[t,r])=>({...e,[t]:(e[t]||[]).concat(r)})),e)}function te(e,t={}){const r=a.Store.from(e).get("configuration")||{};return{...r,...t,mount:ee(r.mount,t.mount)}}m({provide:Z,deps:[x],useFactory:e=>e.logger})})(),n})()));
//# sourceMappingURL=di.umd.min.js.map