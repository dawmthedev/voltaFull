"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformCache = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const logger_1 = require("@tsed/logger");
const async_hooks_1 = require("async_hooks");
const getPrefix_js_1 = require("../utils/getPrefix.js");
const defaultKeyResolver = (args) => {
    return args.map((arg) => ((0, core_1.isClass)(arg) ? JSON.stringify((0, json_mapper_1.serialize)(arg)) : arg)).join(":");
};
const storage = new async_hooks_1.AsyncLocalStorage();
/**
 * @platform
 */
let PlatformCache = class PlatformCache {
    #cache;
    get cache() {
        return this.#cache;
    }
    async $onInit() {
        const settings = this.settings.get("cache");
        if (settings) {
            this.#cache = await this.createCacheManager(settings);
            await this.injector.emit("$onCreateCacheManager", this.#cache);
        }
    }
    getKeysOf(target, propertyKey) {
        const prefix = (0, getPrefix_js_1.getPrefix)(target, propertyKey);
        return this.keys(`${prefix.join(":")}:*`);
    }
    disabled() {
        return !this.settings.get("cache");
    }
    defaultKeyResolver() {
        return this.settings.get("cache.keyResolver", defaultKeyResolver);
    }
    defaultTtl() {
        return this.settings.get("cache.ttl");
    }
    calculateTTL(result, currentTtl) {
        const ttl = currentTtl === undefined ? this.defaultTtl() : currentTtl;
        return (0, core_1.isFunction)(ttl) ? ttl(result) : ttl;
    }
    ttl(key) {
        if (this.cache && "store" in this.cache && this.cache.store.ttl) {
            return this.cache.store.ttl(key);
        }
        return Promise.resolve();
    }
    wrap(key, fetch, ttl) {
        if (!this.cache) {
            return fetch();
        }
        return this.cache?.wrap(key, fetch, ttl);
    }
    get(key, options = {}) {
        return Promise.resolve((0, json_mapper_1.deserialize)(this.cache?.get(key), options));
    }
    async set(key, value, options) {
        await this.cache?.set(key, value, options?.ttl);
        return;
    }
    async getCachedObject(key) {
        try {
            return await this.get(key);
        }
        catch (er) {
            this.logger.error({
                event: "CACHE_ERROR",
                method: "getCachedObject",
                error: er
            });
        }
    }
    async setCachedObject(key, data, opts) {
        try {
            await this.set(key, {
                ...opts,
                data: JSON.stringify(data)
            }, {
                ttl: opts.ttl
            });
        }
        catch (er) {
            this.logger.error({
                event: "CACHE_ERROR",
                method: "setCachedObject",
                error: er
            });
        }
    }
    async del(key) {
        await this.cache?.del(key);
    }
    async reset() {
        // @ts-ignore
        await this.cache?.reset();
    }
    keys(...args) {
        if (this.cache && "store" in this.cache && this.cache.store.keys) {
            return this.cache.store.keys(...args);
        }
        return Promise.resolve([]);
    }
    async deleteKeys(patterns) {
        const keys = await this.keys(patterns);
        await Promise.all(keys.map((key) => this.del(key)));
        return keys;
    }
    /**
     * Use micromatch instead native patterns. Use this method if the native store method doesn't support glob patterns
     * @param patterns
     */
    async getMatchingKeys(patterns) {
        const [keys, { default: micromatch }] = await Promise.all([this.keys(), import("micromatch")]);
        return micromatch(keys, patterns);
    }
    async deleteMatchingKeys(patterns) {
        const keys = await this.getMatchingKeys(patterns);
        await Promise.all(keys.map((key) => this.del(key)));
        return keys;
    }
    refresh(callback) {
        return storage.run({ forceRefresh: true }, callback);
    }
    isForceRefresh() {
        return !!storage.getStore()?.forceRefresh;
    }
    async createCacheManager(settings) {
        const { caches, store = "memory", ttl, ...props } = settings;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { multiCaching, caching } = await import("cache-manager");
        return caches?.length
            ? multiCaching(caches)
            : caching(this.mapStore(store), {
                ...props,
                ttl
            });
    }
    mapStore(store) {
        if (!(0, core_1.isString)(store) && "create" in store) {
            return store.create;
        }
        return store;
    }
};
tslib_1.__decorate([
    (0, di_1.Configuration)(),
    tslib_1.__metadata("design:type", Object)
], PlatformCache.prototype, "settings", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", di_1.InjectorService)
], PlatformCache.prototype, "injector", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", logger_1.Logger)
], PlatformCache.prototype, "logger", void 0);
PlatformCache = tslib_1.__decorate([
    (0, di_1.Module)()
], PlatformCache);
exports.PlatformCache = PlatformCache;
//# sourceMappingURL=PlatformCache.js.map