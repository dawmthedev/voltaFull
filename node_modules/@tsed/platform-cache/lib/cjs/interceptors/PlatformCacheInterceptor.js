"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformCacheInterceptor = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const logger_1 = require("@tsed/logger");
const http_1 = require("http");
const PlatformCache_js_1 = require("../services/PlatformCache.js");
const getPrefix_js_1 = require("../utils/getPrefix.js");
const isEndpoint_js_1 = require("../utils/isEndpoint.js");
const cleanHeaders = (headers, blacklist) => {
    return Object.entries(headers)
        .filter(([key]) => !blacklist.includes(key.toLowerCase()))
        .reduce((headers, [key, value]) => {
        return {
            ...headers,
            [key]: value
        };
    }, {});
};
/**
 * @platform
 */
let PlatformCacheInterceptor = class PlatformCacheInterceptor {
    intercept(context, next) {
        if (this.cache.disabled()) {
            return next();
        }
        if (!(0, isEndpoint_js_1.isEndpoint)(context.target, context.propertyKey)) {
            return this.cacheMethod(context, next);
        }
        return this.cacheResponse(context, next);
    }
    async canRefreshInBackground(key, { refreshThreshold, ttl }, next) {
        const inQueue = await this.hasKeyInQueue(key);
        if (refreshThreshold && !inQueue) {
            await this.addKeyToQueue(key);
            const currentTTL = await this.cache.ttl(key);
            const calculatedTTL = this.cache.calculateTTL(currentTTL, ttl);
            if (currentTTL === undefined || currentTTL < calculatedTTL - refreshThreshold) {
                await next();
            }
            await this.deleteKeyFromQueue(key);
        }
    }
    async cacheMethod(context, next) {
        const { key, type, ttl, collectionType, refreshThreshold, args, canCache } = this.getOptions(context);
        const set = (result) => {
            if (!canCache || (canCache && canCache(result))) {
                const calculatedTTL = this.cache.calculateTTL(result, ttl);
                const data = (0, json_mapper_1.serialize)(result, { type, collectionType });
                this.cache.setCachedObject(key, data, { args, ttl: calculatedTTL });
            }
        };
        const cachedObject = await this.cache.getCachedObject(key);
        if (!cachedObject || this.cache.isForceRefresh()) {
            const result = await next();
            if (!(!cachedObject && this.cache.isForceRefresh())) {
                set(result);
            }
            return result;
        }
        this.canRefreshInBackground(key, { refreshThreshold, ttl }, async () => {
            const result = await next();
            await set(result);
        }).catch((er) => this.logger.error({
            event: "CACHE_ERROR",
            method: "cacheMethod",
            concerned_key: key,
            class_name: (0, core_1.nameOf)(context.target),
            property_key: context.propertyKey,
            error_description: er.message,
            stack: er.stack
        }));
        const { data } = cachedObject;
        return (0, json_mapper_1.deserialize)(JSON.parse(data), { collectionType, type });
    }
    async cacheResponse(context, next) {
        const { request, response } = context.args[context.args.length - 1];
        if (request.method !== "GET") {
            return next();
        }
        const { key, ttl, args, $ctx } = this.getOptions(context);
        const cachedObject = await this.cache.getCachedObject(key);
        if (cachedObject && !(request.get("cache-control") === "no-cache")) {
            return this.sendResponse(cachedObject, $ctx);
        }
        const result = await next();
        const calculatedTTL = this.cache.calculateTTL(result, ttl);
        $ctx.response.setHeaders({
            "cache-control": `max-age=${calculatedTTL}`
        });
        // cache final response with his headers and body
        response.onEnd(() => {
            this.cache.setCachedObject(key, response.getBody(), {
                ttl: calculatedTTL,
                args,
                headers: cleanHeaders(response.getHeaders(), this.blacklist)
            });
        });
        return result;
    }
    getArgs(context) {
        return context.args.reduce((args, arg) => {
            if (arg instanceof di_1.DIContext || arg instanceof http_1.IncomingMessage || arg instanceof http_1.ServerResponse) {
                return args;
            }
            if ((0, core_1.isClass)(arg)) {
                return args.concat((0, json_mapper_1.serialize)(arg));
            }
            return args.concat(arg);
        }, []);
    }
    getOptions(context) {
        const $ctx = context.args[context.args.length - 1];
        const { ttl, type, collectionType, key: k = this.cache.defaultKeyResolver(), refreshThreshold } = context.options || {};
        let { canCache } = context.options || {};
        const args = this.getArgs(context);
        const keyArgs = (0, core_1.isString)(k) ? k : k(args, $ctx);
        if (canCache && canCache === "no-nullish") {
            canCache = (item) => ![null, undefined].includes(item);
        }
        return {
            key: [...[this.prefix, ...(0, getPrefix_js_1.getPrefix)(context.target, context.propertyKey)].filter(Boolean), keyArgs].join(":"),
            refreshThreshold,
            ttl,
            type,
            args,
            collectionType,
            keyArgs,
            canCache,
            $ctx
        };
    }
    async hasKeyInQueue(key) {
        return !!(await this.cache.get(`$$queue:${key}`));
    }
    async addKeyToQueue(key) {
        await this.cache.set(`$$queue:${key}`, true, { ttl: 120 });
    }
    async deleteKeyFromQueue(key) {
        await this.cache.del(`$$queue:${key}`);
    }
    sendResponse(cachedObject, $ctx) {
        const { headers, ttl } = cachedObject;
        const { request, response } = $ctx;
        const requestEtag = request.get("if-none-match");
        if (requestEtag && headers.etag === requestEtag) {
            response.status(304).setHeaders(headers).body(undefined);
            return undefined;
        }
        const data = JSON.parse(cachedObject.data);
        $ctx.response
            .setHeaders({
            ...headers,
            "x-cached": "true",
            "cache-control": `max-age=${ttl}`
        })
            .body(data);
        return data;
    }
};
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", PlatformCache_js_1.PlatformCache)
], PlatformCacheInterceptor.prototype, "cache", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", logger_1.Logger)
], PlatformCacheInterceptor.prototype, "logger", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("cache.prefix", ""),
    tslib_1.__metadata("design:type", String)
], PlatformCacheInterceptor.prototype, "prefix", void 0);
tslib_1.__decorate([
    (0, di_1.Constant)("cache.ignoreHeaders", ["content-length", "x-request-id", "cache-control", "vary", "content-encoding"]),
    tslib_1.__metadata("design:type", Array)
], PlatformCacheInterceptor.prototype, "blacklist", void 0);
PlatformCacheInterceptor = tslib_1.__decorate([
    (0, di_1.Interceptor)()
], PlatformCacheInterceptor);
exports.PlatformCacheInterceptor = PlatformCacheInterceptor;
//# sourceMappingURL=PlatformCacheInterceptor.js.map