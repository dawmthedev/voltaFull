import { __decorate, __metadata } from "tslib";
import { isClass, isFunction, isString } from "@tsed/core";
import { Configuration, Inject, InjectorService, Module } from "@tsed/di";
import { deserialize, serialize } from "@tsed/json-mapper";
import { Logger } from "@tsed/logger";
import { AsyncLocalStorage } from "async_hooks";
import { getPrefix } from "../utils/getPrefix.js";
const defaultKeyResolver = (args) => {
    return args.map((arg) => (isClass(arg) ? JSON.stringify(serialize(arg)) : arg)).join(":");
};
const storage = new AsyncLocalStorage();
/**
 * @platform
 */
let PlatformCache = class PlatformCache {
    #cache;
    get cache() {
        return this.#cache;
    }
    async $onInit() {
        const settings = this.settings.get("cache");
        if (settings) {
            this.#cache = await this.createCacheManager(settings);
            await this.injector.emit("$onCreateCacheManager", this.#cache);
        }
    }
    getKeysOf(target, propertyKey) {
        const prefix = getPrefix(target, propertyKey);
        return this.keys(`${prefix.join(":")}:*`);
    }
    disabled() {
        return !this.settings.get("cache");
    }
    defaultKeyResolver() {
        return this.settings.get("cache.keyResolver", defaultKeyResolver);
    }
    defaultTtl() {
        return this.settings.get("cache.ttl");
    }
    calculateTTL(result, currentTtl) {
        const ttl = currentTtl === undefined ? this.defaultTtl() : currentTtl;
        return isFunction(ttl) ? ttl(result) : ttl;
    }
    ttl(key) {
        if (this.cache && "store" in this.cache && this.cache.store.ttl) {
            return this.cache.store.ttl(key);
        }
        return Promise.resolve();
    }
    wrap(key, fetch, ttl) {
        if (!this.cache) {
            return fetch();
        }
        return this.cache?.wrap(key, fetch, ttl);
    }
    get(key, options = {}) {
        return Promise.resolve(deserialize(this.cache?.get(key), options));
    }
    async set(key, value, options) {
        await this.cache?.set(key, value, options?.ttl);
        return;
    }
    async getCachedObject(key) {
        try {
            return await this.get(key);
        }
        catch (er) {
            this.logger.error({
                event: "CACHE_ERROR",
                method: "getCachedObject",
                error: er
            });
        }
    }
    async setCachedObject(key, data, opts) {
        try {
            await this.set(key, {
                ...opts,
                data: JSON.stringify(data)
            }, {
                ttl: opts.ttl
            });
        }
        catch (er) {
            this.logger.error({
                event: "CACHE_ERROR",
                method: "setCachedObject",
                error: er
            });
        }
    }
    async del(key) {
        await this.cache?.del(key);
    }
    async reset() {
        // @ts-ignore
        await this.cache?.reset();
    }
    keys(...args) {
        if (this.cache && "store" in this.cache && this.cache.store.keys) {
            return this.cache.store.keys(...args);
        }
        return Promise.resolve([]);
    }
    async deleteKeys(patterns) {
        const keys = await this.keys(patterns);
        await Promise.all(keys.map((key) => this.del(key)));
        return keys;
    }
    /**
     * Use micromatch instead native patterns. Use this method if the native store method doesn't support glob patterns
     * @param patterns
     */
    async getMatchingKeys(patterns) {
        const [keys, { default: micromatch }] = await Promise.all([this.keys(), import("micromatch")]);
        return micromatch(keys, patterns);
    }
    async deleteMatchingKeys(patterns) {
        const keys = await this.getMatchingKeys(patterns);
        await Promise.all(keys.map((key) => this.del(key)));
        return keys;
    }
    refresh(callback) {
        return storage.run({ forceRefresh: true }, callback);
    }
    isForceRefresh() {
        return !!storage.getStore()?.forceRefresh;
    }
    async createCacheManager(settings) {
        const { caches, store = "memory", ttl, ...props } = settings;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { multiCaching, caching } = await import("cache-manager");
        return caches?.length
            ? multiCaching(caches)
            : caching(this.mapStore(store), {
                ...props,
                ttl
            });
    }
    mapStore(store) {
        if (!isString(store) && "create" in store) {
            return store.create;
        }
        return store;
    }
};
__decorate([
    Configuration(),
    __metadata("design:type", Object)
], PlatformCache.prototype, "settings", void 0);
__decorate([
    Inject(),
    __metadata("design:type", InjectorService)
], PlatformCache.prototype, "injector", void 0);
__decorate([
    Inject(),
    __metadata("design:type", Logger)
], PlatformCache.prototype, "logger", void 0);
PlatformCache = __decorate([
    Module()
], PlatformCache);
export { PlatformCache };
//# sourceMappingURL=PlatformCache.js.map