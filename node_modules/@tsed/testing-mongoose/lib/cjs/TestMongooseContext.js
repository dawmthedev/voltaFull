"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestMongooseContext = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const mongoose_1 = require("@tsed/mongoose");
const mongodb_memory_server_1 = require("mongodb-memory-server");
const path_1 = require("path");
const mongoose_2 = require("mongoose");
const semver_1 = tslib_1.__importDefault(require("semver"));
const downloadDir = (0, path_1.resolve)(`${require.resolve("mongodb-memory-server")}/../../.cache/mongodb-memory-server/mongodb-binaries`);
class TestMongooseContext extends common_1.PlatformTest {
    static getMongo() {
        // @ts-ignore
        return global.__MONGOD__;
    }
    static async install({ replicaSet, ...opts } = {}) {
        if (!TestMongooseContext.getMongo()) {
            // @ts-ignore
            global.__MONGOD__ = await (replicaSet ? mongodb_memory_server_1.MongoMemoryReplSet : mongodb_memory_server_1.MongoMemoryServer).create({
                ...opts,
                binary: {
                    ...(opts.binary || {}),
                    downloadDir
                }
            });
        }
        return TestMongooseContext.getMongooseOptions();
    }
    /**
     * Connect to the in-memory database.
     */
    static bootstrap(mod, options = {}) {
        return async function before() {
            const config = await TestMongooseContext.install(options.mongod);
            const before = common_1.PlatformTest.bootstrap(mod, {
                ...options,
                mongoose: config
            });
            await before();
        };
    }
    static async create(options = {}) {
        options.mongoose = await TestMongooseContext.install(options.mongod);
        return common_1.PlatformTest.create(options);
    }
    /**
     * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.
     */
    static async reset() {
        await common_1.PlatformTest.reset();
        await TestMongooseContext.getMongo().stop();
    }
    /**
     *
     */
    static async clearDatabase() {
        const mongooseService = common_1.PlatformTest.get(mongoose_1.MongooseService);
        const promises = [];
        for (const connection of mongooseService.connections.values()) {
            promises.push(...Object.values(connection.collections).map((collection) => collection.deleteMany({})));
        }
        await Promise.all(promises);
    }
    static async getMongooseOptions() {
        const mongo = TestMongooseContext.getMongo();
        try {
            !["running", "starting"].includes(mongo.state) && (await mongo.start());
        }
        catch (er) { }
        const url = mongo.getUri();
        return {
            url,
            connectionOptions: semver_1.default.lt(mongoose_2.version, "6.0.0")
                ? {
                    useCreateIndex: true,
                    useUnifiedTopology: true,
                    useNewUrlParser: true
                }
                : {}
        };
    }
}
exports.TestMongooseContext = TestMongooseContext;
//# sourceMappingURL=TestMongooseContext.js.map