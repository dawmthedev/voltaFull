"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSchemaTypeOptions = exports.buildMongooseSchema = exports.getSchemaToken = exports.getSchema = exports.createSchema = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const json_mapper_1 = require("@tsed/json-mapper");
const schema_1 = require("@tsed/schema");
const change_case_1 = require("change-case");
const mongoose_1 = tslib_1.__importDefault(require("mongoose"));
const constants_js_1 = require("../constants/constants.js");
const resolveRefType_js_1 = require("./resolveRefType.js");
const schemaOptions_js_1 = require("./schemaOptions.js");
/**
 * @ignore
 */
function setUpSchema({ schema, virtuals }, options) {
    const mongooseSchema = new mongoose_1.default.Schema(schema, options);
    for (const [key, options] of virtuals.entries()) {
        mongooseSchema.virtual(key, options);
    }
    return mongooseSchema;
}
/**
 * @ignore
 */
function isVirtualRef(target) {
    return !!(target.ref && target.localField && target.foreignField);
}
function hasVersionField(schema, versionKey) {
    // Check if versioning was disabled explicitly
    if (!versionKey)
        return false;
    // Check for alternative version field in schema
    return versionKey in schema.paths;
}
function createSchema(target, options = {}) {
    const entity = schema_1.JsonEntityStore.from(target);
    const schemaOptionsFromStore = entity.store.get(constants_js_1.MONGOOSE_SCHEMA_OPTIONS) || {};
    options.schemaOptions = { ...options.schemaOptions, ...schemaOptionsFromStore };
    if (entity.schema.isDiscriminator) {
        options.schemaOptions.discriminatorKey = entity.schema.discriminator().propertyName;
    }
    const schema = setUpSchema(buildMongooseSchema(target), options.schemaOptions);
    (0, schemaOptions_js_1.schemaOptions)(target, options);
    const outputVersionKey = hasVersionField(schema, options.schemaOptions?.versionKey);
    schema.methods.toClass = function toClass() {
        return (0, json_mapper_1.deserialize)(this.toObject({
            virtuals: true,
            versionKey: outputVersionKey,
            flattenMaps: true
        }), {
            type: target,
            useAlias: false,
            additionalProperties: true,
            disabledUnsecureConstructor: false,
            groups: false
        });
    };
    schema.methods.toJSON = function toJSON(options) {
        return (0, json_mapper_1.serialize)(this.toClass(), options);
    };
    schema.loadClass(target);
    core_1.Store.from(target).set(constants_js_1.MONGOOSE_SCHEMA, schema);
    return schema;
}
exports.createSchema = createSchema;
/**
 * Get a schema already created. If the schema doesn't exists in registry, it'll be created.
 * @param target
 * @param options
 */
function getSchema(target, options = {}) {
    const store = core_1.Store.from(target);
    if (!store.has(constants_js_1.MONGOOSE_SCHEMA)) {
        createSchema(target, options);
    }
    return store.get(constants_js_1.MONGOOSE_SCHEMA);
}
exports.getSchema = getSchema;
function getSchemaToken(target, options) {
    const collectionName = options.name || (0, core_1.nameOf)(target);
    const token = Symbol.for((0, change_case_1.pascalCase)(`${collectionName}Schema`));
    return { token, collectionName };
}
exports.getSchemaToken = getSchemaToken;
/**
 * @ignore
 */
function buildMongooseSchema(target) {
    const properties = (0, schema_1.getProperties)(target, { withIgnoredProps: true, mongoose: true, groups: false });
    const schema = { schema: {}, virtuals: new Map() };
    properties.forEach((propertyMetadata, key) => {
        // Keeping the Mongoose Schema separate, so it can overwrite everything once schema has been built.
        const schemaTypeOptions = propertyMetadata.store.get(constants_js_1.MONGOOSE_SCHEMA) || {};
        if (schemaTypeOptions.schemaIgnore || propertyMetadata.isDiscriminatorKey() || propertyMetadata.isGetterOnly()) {
            return;
        }
        if (schemaTypeOptions.ref) {
            schemaTypeOptions.ref = (0, resolveRefType_js_1.resolveRefType)(schemaTypeOptions.ref);
        }
        if (isVirtualRef(schemaTypeOptions)) {
            schema.virtuals.set(key, schemaTypeOptions);
            return;
        }
        schema.schema[key] = createSchemaTypeOptions(propertyMetadata);
    });
    return schema;
}
exports.buildMongooseSchema = buildMongooseSchema;
/**
 * @ignore
 */
function createSchemaTypeOptions(propEntity) {
    const key = propEntity.propertyKey;
    const rawMongooseSchema = propEntity.store.get(constants_js_1.MONGOOSE_SCHEMA) || {};
    let schemaTypeOptions = {
        required: propEntity.required
            ? function () {
                return propEntity.isRequired(this[key]);
            }
            : false
    };
    if (!propEntity.isClass) {
        const jsonSchema = propEntity.itemSchema.toJSON();
        const { minimum: min, maximum: max, minLength: minlength, maxLength: maxlength } = jsonSchema;
        let match = jsonSchema.pattern;
        if (match) {
            match = new RegExp(match);
        }
        schemaTypeOptions = {
            ...schemaTypeOptions,
            type: propEntity.type,
            match: match,
            min,
            max,
            minlength,
            maxlength,
            enum: /*jsonSchema["enum"] instanceof JsonSchema ? jsonSchema["enum"].toJSON().enum :*/ jsonSchema["enum"],
            default: jsonSchema["default"]
        };
    }
    else if (!rawMongooseSchema.ref) {
        // References are handled by the final merge
        schemaTypeOptions = { ...schemaTypeOptions, type: getSchema(propEntity.type) };
    }
    schemaTypeOptions = (0, core_1.cleanObject)({ ...schemaTypeOptions, ...rawMongooseSchema });
    if (propEntity.isCollection) {
        if (propEntity.isArray) {
            return [schemaTypeOptions];
        }
        // Can be a Map or a Set;
        // Mongoose implements only Map;
        if (propEntity.collectionType !== Map) {
            throw new Error(`Invalid collection type. ${(0, core_1.nameOf)(propEntity.collectionType)} is not supported.`);
        }
        return { type: Map, of: schemaTypeOptions };
    }
    return schemaTypeOptions;
}
exports.createSchemaTypeOptions = createSchemaTypeOptions;
//# sourceMappingURL=createSchema.js.map