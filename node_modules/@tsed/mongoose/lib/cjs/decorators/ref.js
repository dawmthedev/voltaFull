"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ref = void 0;
const core_1 = require("@tsed/core");
const json_mapper_1 = require("@tsed/json-mapper");
const schema_1 = require("@tsed/schema");
const mongoose_1 = require("mongoose");
const constants_js_1 = require("../constants/constants.js");
const MongooseSchemaTypes_js_1 = require("../interfaces/MongooseSchemaTypes.js");
const MongooseModels_js_1 = require("../registries/MongooseModels.js");
function isRef(value) {
    return (0, core_1.isObjectID)(value) || (0, core_1.isString)(value);
}
function PopulateGroups(populatedGroups) {
    return (0, core_1.useDecorators)((0, schema_1.ForwardGroups)(true), (0, schema_1.JsonEntityFn)((store) => {
        store.schema.$hooks.on("oneOf", (obj, givenGroups) => {
            if ((0, schema_1.matchGroups)(populatedGroups, givenGroups)) {
                return obj.filter((x) => x.type === "string"); // keep the object id;
            }
            else {
                return obj.filter((x) => x.type !== "string"); // keep the ref definition
            }
        });
    }));
}
/**
 * Define a property as mongoose reference to other Model (decorated with @Model).
 *
 * ### Example
 *
 * ```typescript
 *
 * @Model()
 * class FooModel {
 *
 *    @Ref(Foo2Model)
 *    field: Ref<Foo2Model>
 *
 *    @Ref(Foo2Model)
 *    list: Ref<Foo2Model>[]
 * }
 *
 * @Model()
 * class Foo2Model {
 * }
 * ```
 *
 * @param model
 * @param options
 * @returns {Function}
 * @decorator
 * @mongoose
 * @property
 */
function Ref(model, options = MongooseSchemaTypes_js_1.MongooseSchemaTypes.OBJECT_ID) {
    if (!model) {
        throw new Error("A model is required on `@Ref(model)` decorator. Please give a model or wrap it inside an arrow function if you have a circular reference.");
    }
    const getType = () => ((0, core_1.isString)(model) ? MongooseModels_js_1.MongooseModels.get(model) : (0, core_1.isArrowFn)(model) ? model() : model);
    const populatedGroups = ((0, core_1.isObject)(options) && options.populatedGroups) || [];
    return (0, core_1.useDecorators)((0, schema_1.Property)(Object), (0, core_1.StoreMerge)(constants_js_1.MONGOOSE_SCHEMA, {
        type: mongoose_1.Schema.Types[(0, core_1.isObject)(options) ? options.type || MongooseSchemaTypes_js_1.MongooseSchemaTypes.OBJECT_ID : options],
        ref: model
    }), (0, json_mapper_1.OnDeserialize)((value) => {
        if (isRef(value)) {
            return value.toString();
        }
        if ((0, core_1.isCollection)(value) && isRef(value[0])) {
            return value.map(String);
        }
        return (0, json_mapper_1.deserialize)(value, { type: getType(), useAlias: false });
    }), (0, json_mapper_1.OnSerialize)((value, ctx) => {
        if (isRef(value)) {
            return value.toString();
        }
        if ((0, core_1.isCollection)(value) && isRef(value[0])) {
            return value.map(String);
        }
        const type = getType();
        return (0, json_mapper_1.serialize)(value, { ...ctx, type });
    }), (0, schema_1.OneOf)((0, schema_1.string)().example("5ce7ad3028890bd71749d477").description("A reference ObjectID"), (0, schema_1.lazyRef)(getType)), populatedGroups.length && PopulateGroups(populatedGroups));
}
exports.Ref = Ref;
//# sourceMappingURL=ref.js.map