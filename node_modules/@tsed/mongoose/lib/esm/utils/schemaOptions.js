import { deepMerge, Store } from "@tsed/core";
import { MONGOOSE_SCHEMA_OPTIONS } from "../constants/constants.js";
/**
 * @ignore
 */
export function schemaOptions(target, options) {
    const store = Store.from(target);
    if (!store.has(MONGOOSE_SCHEMA_OPTIONS)) {
        store.set(MONGOOSE_SCHEMA_OPTIONS, {});
    }
    if (options) {
        store.set(MONGOOSE_SCHEMA_OPTIONS, deepMerge(store.get(MONGOOSE_SCHEMA_OPTIONS), options));
    }
    return store.get(MONGOOSE_SCHEMA_OPTIONS);
}
function mapHookArgs(hook) {
    return [hook.method, hook.options || hook.fn, hook.options ? hook.fn : undefined].filter(Boolean);
}
/**
 * @ignore
 */
export function buildPreHook(fn) {
    return fn.length === 1
        ? function () {
            return fn(this);
        }
        : // we need to explicitly gives args to avoid a bug with mongoose
            function (next, arg1, arg2) {
                return fn(this, next, arg1, arg2);
            };
}
/**
 * @ignore
 */
export function applySchemaOptions(schema, options) {
    if (options.plugins) {
        options.plugins.forEach((item) => schema.plugin(item.plugin, item.options));
    }
    if (options.indexes) {
        options.indexes.forEach((item) => schema.index(item.fields, item.options));
    }
    if (options.pre) {
        options.pre.forEach((item) => {
            item = {
                ...item,
                fn: buildPreHook(item.fn)
            };
            schema.pre(...mapHookArgs(item));
        });
    }
    if (options.post) {
        options.post.forEach((item) => schema.post(...mapHookArgs(item)));
    }
}
//# sourceMappingURL=schemaOptions.js.map