import { isString, StoreMerge, useDecorators } from "@tsed/core";
import { Description, Example, OneOf, Property, string } from "@tsed/schema";
import { Schema as MongooseSchema } from "mongoose";
import { MONGOOSE_SCHEMA } from "../constants/constants.js";
import { deserialize, OnDeserialize, OnSerialize, serialize } from "@tsed/json-mapper";
import { MongooseModels } from "../registries/MongooseModels.js";
function isRef(value) {
    return (value && value._bsontype) || isString(value);
}
function getType(refPath, ctx) {
    return (ctx?.self[refPath] && MongooseModels.get(ctx.self[refPath])) || Object;
}
/**
 * Define a property as mongoose reference to other Model (decorated with @Model).
 *
 * ### Example
 *
 * ```typescript
 * @Model()
 * class FooModel {
 *
 *    @DynamicRef('type')
 *    field: DynamicRef<OtherFooModel | OtherModel>
 *
 *    @Enum(['OtherFooModel', 'OtherModel'])
 *    type: string
 * }
 *
 * @Model()
 * class OtherFooModel {
 * }
 *
 * @Model()
 * class OtherModel {
 * }
 * ```
 *
 * @param refPath {String} the path to apply the correct model
 * @param types {Type} the classes to generate the correct json schema
 * @returns {Function}
 * @decorator
 * @mongoose
 * @property
 */
export function DynamicRef(refPath, ...types) {
    return useDecorators(Property(Object), Example("5ce7ad3028890bd71749d477"), Description("A reference ObjectID"), StoreMerge(MONGOOSE_SCHEMA, {
        type: MongooseSchema.Types.ObjectId,
        refPath
    }), OnDeserialize((value, ctx) => {
        if (isRef(value)) {
            return value.toString();
        }
        return deserialize(value, { ...ctx, type: getType(refPath, ctx) });
    }), OnSerialize((value, ctx) => {
        if (isRef(value)) {
            return value.toString();
        }
        return serialize(value, { ...ctx, type: getType(refPath, ctx) });
    }), OneOf(string().example("5ce7ad3028890bd71749d477").description("A reference ObjectID"), ...types));
}
//# sourceMappingURL=dynamicRef.js.map