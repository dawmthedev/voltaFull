import { isBoolean, isNumber, isString } from "@tsed/core";
import { ARRAY_PROPERTIES, BOOLEAN_PROPERTIES, COMMON_PROPERTIES, MANY_OF_PROPERTIES, NUMBER_PROPERTIES, OBJECT_PROPERTIES, STRING_PROPERTIES } from "../constants/jsonSchemaProperties.js";
function findManyOf(obj) {
    return MANY_OF_PROPERTIES.find((keyword) => obj[keyword]);
}
const RULES = {
    string: { properties: STRING_PROPERTIES, is: isString },
    number: { properties: NUMBER_PROPERTIES, is: isNumber },
    boolean: { properties: BOOLEAN_PROPERTIES, is: isBoolean },
    array: { properties: ARRAY_PROPERTIES, is: () => false },
    object: { properties: OBJECT_PROPERTIES, is: () => false }
};
function pickProperties(type, obj, item) {
    const rule = RULES[type];
    rule?.properties.concat(COMMON_PROPERTIES).forEach((keyword) => {
        if (obj[keyword] !== undefined) {
            if (COMMON_PROPERTIES.includes(keyword)) {
                item[keyword] = obj[keyword].filter(rule.is);
            }
            else {
                item[keyword] = obj[keyword];
                delete obj[keyword];
            }
        }
    });
}
export function alterOneOf(obj, schema, options) {
    const kind = findManyOf(obj);
    if (kind) {
        obj[kind].forEach((item) => {
            pickProperties(item.type, obj, item);
        });
        MANY_OF_PROPERTIES.forEach((keyword) => {
            if (obj[keyword] && options.groups !== false && schema.$hooks.has(keyword)) {
                obj = { ...obj, [keyword]: schema.$hooks.alter(keyword, obj[keyword], [options.groups]) };
            }
        });
        delete obj.const;
        delete obj.enum;
        if (!(obj.items || obj.properties)) {
            delete obj.type;
        }
    }
    return obj;
}
//# sourceMappingURL=alterOneOf.js.map