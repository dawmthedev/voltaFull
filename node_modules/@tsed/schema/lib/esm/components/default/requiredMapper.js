import { uniq } from "@tsed/core";
import { alterRequiredGroups } from "../../hooks/alterRequiredGroups.js";
import { registerJsonSchemaMapper } from "../../registries/JsonSchemaMapperContainer.js";
function mapRequiredProps(obj, schema, options = {}) {
    const { useAlias } = options;
    const props = Object.keys(obj.properties || {});
    return (keys, key) => {
        const aliasedKey = useAlias ? schema.alias.get(key) || key : key;
        if (props.includes(aliasedKey)) {
            return keys.concat(aliasedKey);
        }
        return keys;
    };
}
function extractRequiredProps(obj, schema, options) {
    let required = obj.required || [];
    required = [...required, ...schema.$required];
    if (schema.get("properties")) {
        required = Object.entries(schema.get("properties")).reduce((required, [key, prop]) => {
            if (prop && prop.$selfRequired !== undefined) {
                return prop.$selfRequired ? required.concat(key) : required.filter((k) => k === key);
            }
            return required;
        }, required);
    }
    return alterRequiredGroups(uniq(required), schema, options);
}
export function requiredMapper(obj, schema, options) {
    if (options.groups && options.groups.includes("partial")) {
        if (obj.discriminator) {
            return {
                ...obj,
                required: [obj.discriminator.propertyName]
            };
        }
        return obj;
    }
    let required = extractRequiredProps(obj, schema, options);
    required = uniq(required).reduce(mapRequiredProps(obj, schema, options), []);
    if (obj.discriminator) {
        required.push(obj.discriminator.propertyName);
    }
    if (required.length) {
        obj.required = required;
    }
    return obj;
}
registerJsonSchemaMapper("required", requiredMapper);
//# sourceMappingURL=requiredMapper.js.map