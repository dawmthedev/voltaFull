"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationPipe = void 0;
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const schema_1 = require("@tsed/schema");
const ParamTypes_js_1 = require("../domain/ParamTypes.js");
const RequiredValidationError_js_1 = require("../errors/RequiredValidationError.js");
function cast(value, metadata) {
    try {
        return (0, json_mapper_1.deserialize)(value, {
            type: metadata.type
        });
    }
    catch (er) {
        return value;
    }
}
let ValidationPipe = class ValidationPipe {
    constructor(validators) {
        this.validator = validators[0];
    }
    coerceTypes(value, metadata) {
        if (value === undefined) {
            return value;
        }
        if (value === "null") {
            return null;
        }
        if (metadata.isArray) {
            return [].concat(value);
        }
        if (metadata.isPrimitive) {
            return cast(value, metadata);
        }
        return value;
    }
    skip(value, metadata) {
        return metadata.paramType === ParamTypes_js_1.ParamTypes.PATH && !metadata.isPrimitive;
    }
    transform(value, metadata) {
        if (!this.validator) {
            this.checkIsRequired(value, metadata);
            return value;
        }
        // FIXME See if it's necessary ?
        if (this.skip(value, metadata)) {
            return value;
        }
        value = this.coerceTypes(value, metadata);
        this.checkIsRequired(value, metadata);
        if (value === undefined) {
            return value;
        }
        const schema = (0, schema_1.getJsonSchema)(metadata, {
            customKeys: true
        });
        return this.validator.validate(value, {
            schema,
            type: metadata.isClass ? metadata.type : undefined,
            collectionType: metadata.collectionType
        });
    }
    checkIsRequired(value, metadata) {
        if (metadata.isRequired(value)) {
            throw RequiredValidationError_js_1.RequiredValidationError.from(metadata);
        }
        return true;
    }
};
ValidationPipe = tslib_1.__decorate([
    (0, di_1.Injectable)({
        type: "validator"
    }),
    tslib_1.__param(0, (0, di_1.Inject)("validator:service")),
    tslib_1.__metadata("design:paramtypes", [Array])
], ValidationPipe);
exports.ValidationPipe = ValidationPipe;
//# sourceMappingURL=ValidationPipe.js.map