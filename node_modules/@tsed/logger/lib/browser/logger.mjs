var ge = Object.defineProperty;
var _e = (r, e, t) => e in r ? ge(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var f = (r, e, t) => (_e(r, typeof e != "symbol" ? e + "" : e, t), t), Y = (r, e, t) => {
  if (!e.has(r))
    throw TypeError("Cannot " + t);
};
var q = (r, e, t) => (Y(r, e, "read from private field"), t ? t.call(r) : e.get(r)), K = (r, e, t) => {
  if (e.has(r))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(r) : e.set(r, t);
}, I = (r, e, t, n) => (Y(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t);
const B = /* @__PURE__ */ new Map();
class V {
  static get(e, t) {
    typeof e != "string" && (e = e.$name), B.has(e) || (e = "colored", console.warn(e + " layout doesn't exists"));
    const n = B.get(e);
    return new n.provide(t);
  }
}
var S;
class me {
  constructor(e) {
    K(this, S, void 0);
    this.config = e, this.configure(e);
  }
  get appenderOptions() {
    return this.__proto__.constructor.$appenderOptions;
  }
  configure(e) {
    var t;
    return Object.assign(this.config, e), I(this, S, V.get(((t = this.appenderOptions) == null ? void 0 : t.defaultLayout) || "colored", this.config)), this.config.layout && I(this, S, V.get(this.config.layout.type, this.config.layout)), this;
  }
  /**
   *
   * @param args
   */
  layout(...e) {
    return q(this, S).transform(...e);
  }
}
S = new WeakMap();
const W = /* @__PURE__ */ new Map();
function Oe(r) {
  return (e) => {
    e.$appenderOptions = r, e.$name = r.name, W.set(r.name, { provide: e });
  };
}
var ye = Object.defineProperty, we = Object.getOwnPropertyDescriptor, Se = (r, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? we(e, t) : e, a = r.length - 1, i; a >= 0; a--)
    (i = r[a]) && (s = (n ? i(e, t, s) : i(s)) || s);
  return n && s && ye(e, t, s), s;
};
let X = class extends me {
  constructor() {
    super(...arguments);
    f(this, "log", console.log.bind(console));
  }
  write(e) {
    this.log(this.layout(e, this.config.timezoneOffset));
  }
};
X = Se([
  Oe({ name: "console" })
], X);
class Te extends Map {
  toJSON() {
    return [...this.entries()].reduce((e, [t, n]) => ({
      ...e,
      [t]: n
    }), {});
  }
}
class xe {
  /**
   * Models a logging event.
   * @constructor
   * @param categoryName
   * @param level
   * @param data
   * @param context
   */
  constructor(e, t, n, s) {
    f(this, "_startTime", /* @__PURE__ */ new Date());
    this.categoryName = e, this.level = t, this.data = n, this.context = s;
  }
  get startTime() {
    return this.data && this.data[0] && this.data[0].time ? this.data[0].time : this._startTime;
  }
  /**
   * @deprecated
   */
  get formatedLevel() {
    return this.formattedLevel;
  }
  get formattedLevel() {
    return (this.level.toString() + "     ").slice(0, 5);
  }
  get cluster() {
    return {};
  }
  get pid() {
    return this.context.get("pid");
  }
  isMessage() {
    return this.data.length && typeof this.data[0] != "object";
  }
  getData() {
    return this.isMessage() ? {} : this.data[0];
  }
  getMessage() {
    return this.isMessage() ? this.data : void 0;
  }
}
class v {
  constructor(e, t) {
    this.level = e, this.levelStr = t, this.level = e, this.levelStr = t;
  }
  static getLevel(e, t) {
    if (e instanceof v)
      return e;
    if (typeof e == "string") {
      const n = e.toUpperCase();
      return se[n] || t;
    }
    return this.getLevel(e.toString());
  }
  toString() {
    return this.levelStr;
  }
  isLessThanOrEqualTo(e) {
    return typeof e == "string" && (e = v.getLevel(e)), this.level <= e.level;
  }
  isGreaterThanOrEqualTo(e) {
    return typeof e == "string" && (e = v.getLevel(e)), this.level >= e.level;
  }
  isEqualTo(e) {
    return typeof e == "string" && (e = v.getLevel(e)), this.level === e.level;
  }
}
const se = {
  ALL: new v(Number.MIN_VALUE, "ALL"),
  TRACE: new v(5e3, "TRACE"),
  DEBUG: new v(1e4, "DEBUG"),
  INFO: new v(2e4, "INFO"),
  WARN: new v(3e4, "WARN"),
  ERROR: new v(4e4, "ERROR"),
  FATAL: new v(5e4, "FATAL"),
  MARK: new v(9007199254740992, "MARK"),
  // 2^53
  OFF: new v(Number.MAX_VALUE, "OFF")
};
function w() {
  return se;
}
class O {
  constructor(e) {
    this.config = e;
  }
}
var ae = { exports: {} };
(function(r) {
  function e(c, u) {
    for (var h = c.toString(); h.length < u; )
      h = "0" + h;
    return h;
  }
  function t(c) {
    return e(c, 2);
  }
  function n(c) {
    var u = Math.abs(c), h = String(Math.floor(u / 60)), d = String(u % 60);
    return h = ("0" + h).slice(-2), d = ("0" + d).slice(-2), c === 0 ? "Z" : (c < 0 ? "+" : "-") + h + ":" + d;
  }
  function s(c, u) {
    typeof c != "string" && (u = c, c = r.exports.ISO8601_FORMAT), u || (u = r.exports.now());
    var h = t(u.getDate()), d = t(u.getMonth() + 1), x = t(u.getFullYear()), M = t(x.substring(2, 4)), j = c.indexOf("yyyy") > -1 ? x : M, A = t(u.getHours()), R = t(u.getMinutes()), E = t(u.getSeconds()), D = e(u.getMilliseconds(), 3), l = n(u.getTimezoneOffset()), o = c.replace(/dd/g, h).replace(/MM/g, d).replace(/y{1,4}/g, j).replace(/hh/g, A).replace(/mm/g, R).replace(/ss/g, E).replace(/SSS/g, D).replace(/O/g, l);
    return o;
  }
  function a(c, u, h, d) {
    c["set" + (d ? "" : "UTC") + u](h);
  }
  function i(c, u, h) {
    var d = c.indexOf("O") < 0, x = !1, M = [
      {
        pattern: /y{1,4}/,
        regexp: "\\d{1,4}",
        fn: function(l, o) {
          a(l, "FullYear", o, d);
        }
      },
      {
        pattern: /MM/,
        regexp: "\\d{1,2}",
        fn: function(l, o) {
          a(l, "Month", o - 1, d), l.getMonth() !== o - 1 && (x = !0);
        }
      },
      {
        pattern: /dd/,
        regexp: "\\d{1,2}",
        fn: function(l, o) {
          x && a(l, "Month", l.getMonth() - 1, d), a(l, "Date", o, d);
        }
      },
      {
        pattern: /hh/,
        regexp: "\\d{1,2}",
        fn: function(l, o) {
          a(l, "Hours", o, d);
        }
      },
      {
        pattern: /mm/,
        regexp: "\\d\\d",
        fn: function(l, o) {
          a(l, "Minutes", o, d);
        }
      },
      {
        pattern: /ss/,
        regexp: "\\d\\d",
        fn: function(l, o) {
          a(l, "Seconds", o, d);
        }
      },
      {
        pattern: /SSS/,
        regexp: "\\d\\d\\d",
        fn: function(l, o) {
          a(l, "Milliseconds", o, d);
        }
      },
      {
        pattern: /O/,
        regexp: "[+-]\\d{1,2}:?\\d{2}?|Z",
        fn: function(l, o) {
          o === "Z" ? o = 0 : o = o.replace(":", "");
          var H = Math.abs(o), ve = (o > 0 ? -1 : 1) * (H % 100 + Math.floor(H / 100) * 60);
          l.setUTCMinutes(l.getUTCMinutes() + ve);
        }
      }
    ], j = M.reduce(
      function(l, o) {
        return o.pattern.test(l.regexp) ? (o.index = l.regexp.match(o.pattern).index, l.regexp = l.regexp.replace(o.pattern, "(" + o.regexp + ")")) : o.index = -1, l;
      },
      { regexp: c, index: [] }
    ), A = M.filter(function(l) {
      return l.index > -1;
    });
    A.sort(function(l, o) {
      return l.index - o.index;
    });
    var R = new RegExp(j.regexp), E = R.exec(u);
    if (E) {
      var D = h || r.exports.now();
      return A.forEach(function(l, o) {
        l.fn(D, E[o + 1]);
      }), D;
    }
    throw new Error(
      "String '" + u + "' could not be parsed as '" + c + "'"
    );
  }
  function g(c, u, h) {
    if (!c)
      throw new Error("pattern must be supplied");
    return i(c, u, h);
  }
  function p() {
    return /* @__PURE__ */ new Date();
  }
  r.exports = s, r.exports.asString = s, r.exports.parse = g, r.exports.now = p, r.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS", r.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO", r.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS", r.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
})(ae);
var _ = ae.exports;
const ie = {
  // styles
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  // grayscale
  white: [37, 39],
  grey: [90, 39],
  black: [90, 39],
  // colors
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
function oe(r) {
  return r ? `\x1B[${ie[r][0]}m` : "";
}
function le(r) {
  return r ? `\x1B[${ie[r][1]}m` : "";
}
function be(r, e) {
  return oe(e) + r + le(e);
}
function Me(r) {
  return r.replace(/\[\d+m|\\u\d+b/gi, "");
}
function Ae(r, e) {
  let t;
  return r ? (t = parseInt(r.substr(1), 10), e.substring(0, t)) : e;
}
function Ee(r, e) {
  let t;
  if (r)
    if (r.charAt(0) === "-")
      for (t = parseInt(r.substr(1), 10); e.length < t; )
        e += " ";
    else
      for (t = parseInt(r, 10); e.length < t; )
        e = ` ${e}`;
  return e;
}
function De(r, e, t) {
  let n = r;
  return n = Ae(e, n), n = Ee(t, n), n;
}
const T = {
  format(r, ...e) {
    return "";
  }
};
function ce(r, e, t) {
  return be(
    T.format(
      "[%s] [%s] [%s] - ",
      _.asString(r.startTime, t),
      r.formattedLevel,
      r.categoryName
    ),
    e
  );
}
function y(r) {
  return (e) => {
    e.$name = r.name, B.set(r.name, { provide: e });
  };
}
var Pe = Object.defineProperty, Ne = Object.getOwnPropertyDescriptor, Fe = (r, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Ne(e, t) : e, a = r.length - 1, i; a >= 0; a--)
    (i = r[a]) && (s = (n ? i(e, t, s) : i(s)) || s);
  return n && s && Pe(e, t, s), s;
};
let G = class extends O {
  /**
   * BasicLayout is a simple layouts for storing the logs. The logs are stored
   * in following format:
   * <pre>
   * [startTime] [logLevel] categoryName - message\n
   * </pre>
   *
   * @author Stephan Strittmatter
   */
  transform(r, e) {
    return ce(r, void 0, e) + T.format(...[].concat(r.data));
  }
};
G = Fe([
  y({ name: "basic" })
], G);
var $ = /* @__PURE__ */ ((r) => (r.ALL = "grey", r.INFO = "green", r.DEBUG = "cyan", r.WARN = "yellow", r.TRACE = "blue", r.ERROR = "red", r.FATAL = "magenta", r.OFF = "grey", r))($ || {}), $e = Object.defineProperty, Le = Object.getOwnPropertyDescriptor, je = (r, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Le(e, t) : e, a = r.length - 1, i; a >= 0; a--)
    (i = r[a]) && (s = (n ? i(e, t, s) : i(s)) || s);
  return n && s && $e(e, t, s), s;
};
let Q = class extends O {
  /**
   * colouredLayout - taken from masylum's fork.
   * same as basicLayout, but with colours.
   */
  transform(r, e) {
    const t = r.level.toString(), n = $[t];
    return ce(r, n, e) + T.format(...[].concat(r.data));
  }
};
Q = je([
  y({ name: "colored" })
], Q);
var Re = Object.defineProperty, Ie = Object.getOwnPropertyDescriptor, Ce = (r, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Ie(e, t) : e, a = r.length - 1, i; a >= 0; a--)
    (i = r[a]) && (s = (n ? i(e, t, s) : i(s)) || s);
  return n && s && Re(e, t, s), s;
};
let k = class extends O {
  transform(r, e) {
    return r.data[0];
  }
};
k = Ce([
  y({ name: "dummy" })
], k);
function ue(r) {
  const e = {
    ...r.context.toJSON(),
    startTime: r.startTime,
    categoryName: r.categoryName,
    level: r.level.toString()
  };
  return e.data = r.data.reduce((t, n) => typeof n == "object" ? (Object.assign(e, n), n.data ? [].concat(t, n.data) : t) : [...t, Me(T.format(n))], []), e;
}
var ze = Object.defineProperty, Ue = Object.getOwnPropertyDescriptor, Be = (r, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Ue(e, t) : e, a = r.length - 1, i; a >= 0; a--)
    (i = r[a]) && (s = (n ? i(e, t, s) : i(s)) || s);
  return n && s && ze(e, t, s), s;
};
let ee = class extends O {
  transform(r, e) {
    const t = ue(r);
    return JSON.stringify(t) + (this.config.separator || "");
  }
};
ee = Be([
  y({ name: "json" })
], ee);
var We = Object.defineProperty, Je = Object.getOwnPropertyDescriptor, Ze = (r, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Je(e, t) : e, a = r.length - 1, i; a >= 0; a--)
    (i = r[a]) && (s = (n ? i(e, t, s) : i(s)) || s);
  return n && s && We(e, t, s), s;
};
let te = class extends O {
  transform(r, e) {
    return T.format(...[].concat(r.data));
  }
};
te = Ze([
  y({ name: "messagePassThrough" })
], te);
var He = Object.defineProperty, Ye = Object.getOwnPropertyDescriptor, qe = (r, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Ye(e, t) : e, a = r.length - 1, i; a >= 0; a--)
    (i = r[a]) && (s = (n ? i(e, t, s) : i(s)) || s);
  return n && s && He(e, t, s), s;
};
let re = class extends O {
  transform(r, e) {
    return ue(r);
  }
};
re = qe([
  y({ name: "object" })
], re);
var fe = Object.defineProperty, Ke = Object.getOwnPropertyDescriptor, Ve = (r, e, t) => e in r ? fe(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, Xe = (r, e, t, n) => {
  for (var s = n > 1 ? void 0 : n ? Ke(e, t) : e, a = r.length - 1, i; a >= 0; a--)
    (i = r[a]) && (s = (n ? i(e, t, s) : i(s)) || s);
  return n && s && fe(e, t, s), s;
}, pe = (r, e, t) => (Ve(r, typeof e != "symbol" ? e + "" : e, t), t), he = (r, e, t) => {
  if (!e.has(r))
    throw TypeError("Cannot " + t);
}, C = (r, e, t) => (he(r, e, "read from private field"), t ? t.call(r) : e.get(r)), z = (r, e, t) => {
  if (e.has(r))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(r) : e.set(r, t);
}, U = (r, e, t, n) => (he(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t), P, N, F;
const Ge = /%(-?[0-9]+)?(\.?[0-9]+)?([[\]cdhmnpjrzxy%])(\{([^}]+)\})?|([^%]+)/, Qe = "%r %p %c - %m%n";
let b = class extends O {
  constructor(r) {
    super(r), z(this, P, void 0), z(this, N, void 0), z(this, F, void 0), pe(this, "replaceToken", (e, t, n) => C(this, P)[e](t, n)), U(this, F, r && r.pattern || Qe), U(this, N, r && r.tokens), U(this, P, new b.LayoutReplacer(C(this, N), this.config.timezoneOffset).build());
  }
  /**
   *
   * @param loggingEvent
   * @param timezoneOffset
   * @returns {string}
   */
  transform(r, e) {
    let t = "", n, s = C(this, F);
    for (; (n = Ge.exec(s)) !== null; ) {
      const a = n[1], i = n[2], g = n[3], p = n[5], c = n[6];
      if (c)
        t += c.toString();
      else {
        const u = this.replaceToken(g, r, p);
        t += De(u, i, a);
      }
      s = s.substr(n.index + n[0].length);
    }
    return t;
  }
};
P = /* @__PURE__ */ new WeakMap();
N = /* @__PURE__ */ new WeakMap();
F = /* @__PURE__ */ new WeakMap();
pe(b, "LayoutReplacer");
b = Xe([
  y({ name: "pattern" })
], b);
class ke {
  constructor() {
    f(this, "_appenders", /* @__PURE__ */ new Map());
    f(this, "_lvls", /* @__PURE__ */ new Map());
  }
  get size() {
    return this._appenders.size;
  }
  /**
   * The `has() method returns a boolean indicating whether an element with the specified configuration name exists or not.
   * @param name Required. The key of the element to test for presence in the Map object.`
   * @returns {boolean}
   */
  has(e) {
    return this._appenders.has(e);
  }
  /**
   * The `get() method returns a specified element from a loggerAppenders.
   * @param name Required. The configuration of the element to return from the Map object.
   * @returns {LoggerAppender}
   */
  get(e) {
    return this._appenders.get(e);
  }
  /**
   * The `set()` method adds or updates an element with a specified key and value to a loggerAppenders object.
   * @param name Required. The key of the element to add to the loggerAppenders object.
   * @param config Required. The config of the element to add to the loggerAppenders object.
   * @returns {LoggerAppender}
   */
  set(e, t) {
    var g;
    const n = typeof t.type == "string" ? t.type : (g = t.type) == null ? void 0 : g.$name, s = {
      level: ["debug", "info", "trace", "error", "warn", "fatal"],
      ...t,
      type: n,
      options: t.options || {}
    };
    if (!W.has(s.type)) {
      const p = new Error(`Appender ${s.type} doesn't exists. Check your configuration:
${JSON.stringify(s)}
`);
      throw p.name = "UNKNOW_APPENDER", p;
    }
    const a = W.get(s.type).provide, i = new a(s);
    return "build" in i && i.build(), this._appenders.set(e, { name: e, instance: i, config: s }), this._lvls.clear(), this;
  }
  /**
   * Remove all configuration that match with the `name`.
   * @param name Required. The key of the element to remove from the loggerAppenders object.
   * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.
   */
  delete(e) {
    let t = this._appenders.delete(e);
    return t && this._lvls.clear(), t;
  }
  /**
   * The `clear() method removes all elements from a loggerAppenders object.
   */
  clear() {
    this._appenders.clear(), this._lvls.clear();
  }
  /**
   * The `forEach()` method executes a provided function once per each key/value pair in the loggerAppenders object, in insertion order.
   * @param callback Function to execute for each element.
   * @param thisArg Value to use as this when executing callback.
   */
  forEach(e, t) {
    this._appenders.forEach(e, t);
  }
  /**
   *
   * @returns {Array}
   */
  toArray() {
    const e = [];
    return this._appenders.forEach((t) => e.push(t)), e;
  }
  /**
   * Return all appenders that match with the given loggingLevel.
   * @param loggingLevel
   * @returns {[BaseAppender]}
   */
  byLogLevel(e) {
    const t = e.toString();
    if (this._lvls.has(t))
      return this._lvls.get(t);
    const n = this.toArray().filter(
      (s) => s.config.levels ? s.config.levels.find((a) => a.toUpperCase() === e.toString()) : !0
    ).map((s) => s.instance);
    return this._lvls.set(e.toString(), n), n;
  }
}
function L(r, e = " ") {
  let t = "";
  for (; r--; )
    t += e;
  return t;
}
function et(r, e) {
  let t = "┌", n = Object.keys(r);
  return n.forEach((s, a) => {
    a !== 0 && a !== n.length && (t += "┬"), t += L(r[s] + 2 * e.padding, "─");
  }), t += "┐", t;
}
function tt(r, e) {
  let t = "└", n = Object.keys(r);
  return n.forEach((s, a) => {
    a !== 0 && a !== n.length && (t += "┴"), t += L(r[s] + 2 * e.padding, "─");
  }), t += "┘", t;
}
function rt(r, e, t = "─") {
  let n = "";
  return Object.keys(r).forEach((s) => {
    n += "│", n += L(r[s] + 2 * e.padding, t);
  }), n += "│", n;
}
function ne(r, e, t) {
  let n = "";
  return Object.keys(e).forEach((s) => {
    n += "│ ", n += r[s], n += L(e[s] + 2 * (t.padding - 1) - r[s].length, " "), n += " ";
  }), n += "│", n;
}
function nt(r, e = {}) {
  e.padding = e.padding || 1, e.header === void 0 && (e.header = {}, Object.keys(r[0]).forEach((s) => e.header[s] = s));
  const t = {};
  Object.keys(e.header).forEach((s) => t[s] = e.header[s].length), r.forEach((s) => {
    Object.keys(t).forEach((a) => t[a] = Math.max(("" + s[a]).length, t[a]));
  });
  let n = "";
  return n += et(t, e) + `
`, n += ne(e.header, t, e) + `
`, r.forEach((s) => {
    n += rt(t, e) + `
`, n += ne(s, t, e) + `
`;
  }), n += tt(t, e), n;
}
class Z {
  /**
   *
   */
  constructor(e = "default") {
    f(this, "_appenders", new ke());
    f(this, "_level");
    /**
     *
     */
    f(this, "_context", new Te());
    this._name = e, this.level = "all";
  }
  get appenders() {
    return this._appenders;
  }
  get level() {
    return this._level.toString();
  }
  set level(e) {
    this._level = v.getLevel(e, "debug");
  }
  get context() {
    return this._context;
  }
  get name() {
    return this._name;
  }
  set name(e) {
    this._name = e;
  }
  /**
   * Create stack trace  the lines of least Logger.
   * @returns {string}
   */
  static createStack() {
    return new Error().stack.replace(`Error
`, "").split(`
`).filter((t, n) => n >= 2).join(`
`);
  }
  isLevelEnabled(e) {
    return this._level.isLessThanOrEqualTo(e);
  }
  /**
   * Prints to stdout with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to printf() (the arguments are all passed to util.format()).
   * @param data
   * @returns {any}
   */
  debug(...e) {
    return this.write(w().DEBUG, e);
  }
  /**
   *
   * @param data
   * @returns {any}
   */
  info(...e) {
    return this.write(w().INFO, e);
  }
  /**
   *
   * @param data
   * @returns {any}
   */
  warn(...e) {
    return this.write(w().WARN, e);
  }
  /**
   * Prints to stderr with newline. Multiple arguments can be passed, with the first used as the primary
   * message and all additional used as substitution values similar to printf() (the arguments are all
   * passed to util.format()).
   * @param data
   * @returns {any}
   */
  error(...e) {
    return this.write(w().ERROR, e);
  }
  fatal(...e) {
    return this.write(w().FATAL, e);
  }
  /**
   *
   * @param data
   * @returns {Logger}
   */
  trace(...e) {
    const t = `
` + Z.createStack() + `
`;
    return e.push(t), this.write(w().TRACE, e);
  }
  /**
   *
   */
  start() {
    return this.level = "ALL", this;
  }
  /**
   *
   */
  stop() {
    return this.level = "OFF", this;
  }
  /**
   *
   * @returns {Promise<any[]>}
   */
  shutdown() {
    this.stop();
    const e = this.appenders.toArray().filter((t) => !!t.instance.shutdown).map((t) => t.instance.shutdown());
    return Promise.all(e);
  }
  /**
   *
   * @param list
   * @param settings
   */
  drawTable(e, t = {}) {
    return nt(e, t);
  }
  /**
   *
   * @param list
   * @param settings
   * @returns {Logger}
   */
  printTable(e, t = {}) {
    return this.info(`
${this.drawTable(e, t)}`), this;
  }
  /**
   *
   * @returns {Logger}
   */
  write(e, t) {
    if (!this.isLevelEnabled(e))
      return this;
    const n = new xe(this._name, e, t, this._context);
    return this.appenders.byLogLevel(e).forEach((s) => {
      s.write(n);
    }), this;
  }
}
function de(r, ...e) {
  const t = /(%?)(%([ojds]))/g;
  if (typeof r == "object" && (r = JSON.stringify(r, null, 2)), e.length) {
    const n = (s, a, i, g) => {
      let p = e.shift();
      switch (g) {
        case "o":
          if (Array.isArray(p)) {
            p = JSON.stringify(p);
            break;
          }
        case "s":
          p = "" + p;
          break;
        case "d":
          p = Number(p);
          break;
        case "j":
          p = JSON.stringify(p);
          break;
      }
      return a ? (e.unshift(p), s) : p;
    };
    r = String(r).replace(t, n);
  }
  return e.length && (r += " " + e.join(" ")), r = String(r).replace(/%{2,2}/g, "%"), "" + r;
}
const m = class m {
  constructor(e, t) {
    /**
     *
     * @param loggingEvent
     * @param specifier
     * @returns {any}
     */
    f(this, "categoryName", (e, t) => {
      let n = e.categoryName;
      if (t) {
        const s = parseInt(t, 10), a = n.split(".");
        s < a.length && (n = a.slice(a.length - s).join("."));
      }
      return n;
    });
    /**
     *
     * @param loggingEvent
     * @param specifier
     * @returns {any}
     */
    f(this, "formatAsDate", (e, t) => {
      let n = _.ISO8601_FORMAT;
      return t && (n = t, n === "ISO8601" ? n = _.ISO8601_FORMAT : n === "ISO8601_WITH_TZ_OFFSET" ? n = _.ISO8601_WITH_TZ_OFFSET_FORMAT : n === "ABSOLUTE" ? n = _.ABSOLUTETIME_FORMAT : n === "DATE" && (n = _.DATETIME_FORMAT)), _.asString(n, e.startTime, this.timezoneOffset);
    });
    /**
     *
     * @returns {string}
     */
    f(this, "hostname", () => m.HOSTNAME || "");
    /**
     *
     * @param loggingEvent
     * @returns {any}
     */
    f(this, "formatMessage", (e) => m.formatter(...e.data));
    f(this, "formatJson", (e) => JSON.stringify(e.data));
    /**
     *
     * @returns {string|string}
     */
    f(this, "endOfLine", () => m.EOL);
    /**
     *
     * @param loggingEvent
     * @returns {string}
     */
    f(this, "logLevel", (e) => e.level.toString());
    /**
     *
     * @param loggingEvent
     * @returns {any}
     */
    f(this, "startTime", (e) => _.asString("hh:mm:ss", e.startTime, this.timezoneOffset));
    /**
     *
     * @param loggingEvent
     * @returns {string}
     */
    f(this, "startColour", (e) => {
      const t = e.level.toString();
      return oe($[t]);
    });
    /**
     *
     * @param loggingEvent
     * @returns {string}
     */
    f(this, "endColour", (e) => {
      const t = e.level.toString();
      return le($[t]);
    });
    /**
     *
     * @returns {string}
     */
    f(this, "percent", () => "%");
    /**
     *
     * @param loggingEvent
     * @returns {string}
     */
    f(this, "pid", (e) => e && e.pid ? e.pid.toString() : "");
    /**
     *
     * @param loggingEvent
     * @param specifier
     * @returns {any}
     */
    f(this, "clusterInfo", (e, t) => e.cluster && t ? t.replace("%m", e.cluster.master).replace("%w", e.cluster.worker).replace("%i", e.cluster.workerId) : e.cluster ? `${e.cluster.worker}@${e.cluster.master}` : this.pid());
    /**
     *
     * @param loggingEvent
     * @param specifier
     * @returns {any}
     */
    f(this, "userDefined", (e, t) => typeof this.tokens[t] < "u" ? typeof this.tokens[t] == "function" ? this.tokens[t](e) : this.tokens[t] : null);
    this.tokens = e, this.timezoneOffset = t;
  }
  build() {
    return {
      c: this.categoryName,
      d: this.formatAsDate,
      h: this.hostname,
      m: this.formatMessage,
      j: this.formatJson,
      n: this.endOfLine,
      p: this.logLevel,
      r: this.startTime,
      "[": this.startColour,
      "]": this.endColour,
      y: this.clusterInfo,
      z: this.pid,
      "%": this.percent,
      x: this.userDefined
    };
  }
};
f(m, "EOL", `
`), f(m, "HOSTNAME", ""), f(m, "formatter", de);
let J = m;
const st = new Z("default");
st.appenders.set("console", { type: "console", levels: ["info", "debug", "trace", "fatal", "error", "warn"] });
b.LayoutReplacer = J;
T.format = de;
export {
  st as $log,
  Oe as Appender,
  W as AppendersRegistry,
  me as BaseAppender,
  O as BaseLayout,
  G as BasicLayout,
  Q as ColoredLayout,
  X as ConsoleAppender,
  k as DummyLayout,
  ee as JsonLayout,
  $ as LOG_COLORS,
  y as Layout,
  V as Layouts,
  B as LayoutsRegistry,
  Te as LogContext,
  xe as LogEvent,
  v as LogLevel,
  Z as Logger,
  ke as LoggerAppenders,
  te as MessagePassThroughLayout,
  re as ObjectLayout,
  b as PatternLayout,
  T as StringUtils,
  tt as buildEndLine,
  rt as buildLine,
  ne as buildLineData,
  et as buildStartLine,
  L as charRepeater,
  be as colorize,
  le as colorizeEnd,
  oe as colorizeStart,
  nt as drawTable,
  de as format,
  w as levels,
  ue as logEventToObject,
  Ee as pad,
  Me as removeColors,
  ce as timestampLevelAndCategory,
  Ae as truncate,
  De as truncateAndPad
};
