"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketIOModule = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
const socket_io_1 = require("socket.io");
const SocketProviderMetadata_js_1 = require("./class/SocketProviderMetadata.js"); // tslint:disable-line: no-unused-variable
const constants_js_1 = require("./constants/constants.js");
const io_js_1 = require("./decorators/io.js");
const SocketIOService_js_1 = require("./services/SocketIOService.js");
const http_1 = tslib_1.__importDefault(require("http"));
const https_1 = tslib_1.__importDefault(require("https"));
const di_1 = require("@tsed/di");
/**
 * @ignore
 */
let SocketIOModule = class SocketIOModule {
    $afterListen() {
        if (this.httpServer) {
            this.io.attach(this.httpServer, { ...this.settings });
        }
        if (this.httpsServer) {
            this.io.attach(this.httpsServer, { ...this.settings });
        }
        if (this.settings.adapter) {
            this.io.adapter(this.settings.adapter);
        }
        this.getWebsocketServices().forEach((provider) => this.socketIOService.addSocketProvider(provider));
        if (!this.disableRoutesSummary) {
            this.printSocketEvents();
        }
        return this.injector.emit("$afterSocketListen");
    }
    $onDestroy() {
        return this.io?.close && this.io?.engine && new Promise((resolve) => this.io.close(() => resolve(undefined)));
    }
    /**
     *
     * @returns {Provider<any>[]}
     */
    getWebsocketServices() {
        return Array.from(this.injector.getProviders(constants_js_1.PROVIDER_TYPE_SOCKET_SERVICE));
    }
    /**
     *
     */
    printSocketEvents() {
        const list = this.getWebsocketServices().reduce((acc, provider) => {
            const socketProvider = new SocketProviderMetadata_js_1.SocketProviderMetadata(provider.store.get("socketIO"));
            if (socketProvider.namespace) {
                socketProvider.getHandlers().forEach((handler) => {
                    acc.push({
                        namespace: socketProvider.namespace,
                        inputEvent: handler.eventName,
                        outputEvent: (handler.returns && handler.returns.eventName) || handler.eventName || "",
                        outputType: (handler.returns && handler.returns.type) || "",
                        name: `${(0, core_1.nameOf)(provider.useClass)}.${handler.methodClassName}`
                    });
                });
            }
            return acc;
        }, []);
        this.injector.logger.info("Socket events mounted:");
        const str = common_1.$log.drawTable(list, {
            padding: 1,
            header: {
                namespace: "Namespace",
                inputEvent: "Input event",
                outputEvent: "Output event",
                outputType: "Output type",
                name: "Class method"
            }
        });
        this.injector.logger.info("\n" + str.trim());
        this.injector.logger.info("Socket server started...");
    }
};
tslib_1.__decorate([
    (0, common_1.Constant)("logger.disableRoutesSummary", false),
    tslib_1.__metadata("design:type", Boolean)
], SocketIOModule.prototype, "disableRoutesSummary", void 0);
tslib_1.__decorate([
    (0, common_1.Constant)("socketIO", {}),
    tslib_1.__metadata("design:type", Object)
], SocketIOModule.prototype, "settings", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", common_1.InjectorService)
], SocketIOModule.prototype, "injector", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(http_1.default.Server),
    tslib_1.__metadata("design:type", Object)
], SocketIOModule.prototype, "httpServer", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(https_1.default.Server),
    tslib_1.__metadata("design:type", Object)
], SocketIOModule.prototype, "httpsServer", void 0);
tslib_1.__decorate([
    (0, io_js_1.IO)(),
    tslib_1.__metadata("design:type", socket_io_1.Server)
], SocketIOModule.prototype, "io", void 0);
tslib_1.__decorate([
    (0, di_1.Inject)(),
    tslib_1.__metadata("design:type", SocketIOService_js_1.SocketIOService)
], SocketIOModule.prototype, "socketIOService", void 0);
SocketIOModule = tslib_1.__decorate([
    (0, common_1.Module)()
], SocketIOModule);
exports.SocketIOModule = SocketIOModule;
//# sourceMappingURL=SocketIOModule.js.map