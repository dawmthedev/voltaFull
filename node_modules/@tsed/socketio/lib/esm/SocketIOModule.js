import { __decorate, __metadata } from "tslib";
import { $log, Constant, InjectorService, Module } from "@tsed/common";
import { nameOf } from "@tsed/core";
import { Server } from "socket.io";
import { SocketProviderMetadata } from "./class/SocketProviderMetadata.js"; // tslint:disable-line: no-unused-variable
import { PROVIDER_TYPE_SOCKET_SERVICE } from "./constants/constants.js";
import { IO } from "./decorators/io.js";
import { SocketIOService } from "./services/SocketIOService.js";
import Http from "http";
import Https from "https";
import { Inject } from "@tsed/di";
/**
 * @ignore
 */
let SocketIOModule = class SocketIOModule {
    $afterListen() {
        if (this.httpServer) {
            this.io.attach(this.httpServer, { ...this.settings });
        }
        if (this.httpsServer) {
            this.io.attach(this.httpsServer, { ...this.settings });
        }
        if (this.settings.adapter) {
            this.io.adapter(this.settings.adapter);
        }
        this.getWebsocketServices().forEach((provider) => this.socketIOService.addSocketProvider(provider));
        if (!this.disableRoutesSummary) {
            this.printSocketEvents();
        }
        return this.injector.emit("$afterSocketListen");
    }
    $onDestroy() {
        return this.io?.close && this.io?.engine && new Promise((resolve) => this.io.close(() => resolve(undefined)));
    }
    /**
     *
     * @returns {Provider<any>[]}
     */
    getWebsocketServices() {
        return Array.from(this.injector.getProviders(PROVIDER_TYPE_SOCKET_SERVICE));
    }
    /**
     *
     */
    printSocketEvents() {
        const list = this.getWebsocketServices().reduce((acc, provider) => {
            const socketProvider = new SocketProviderMetadata(provider.store.get("socketIO"));
            if (socketProvider.namespace) {
                socketProvider.getHandlers().forEach((handler) => {
                    acc.push({
                        namespace: socketProvider.namespace,
                        inputEvent: handler.eventName,
                        outputEvent: (handler.returns && handler.returns.eventName) || handler.eventName || "",
                        outputType: (handler.returns && handler.returns.type) || "",
                        name: `${nameOf(provider.useClass)}.${handler.methodClassName}`
                    });
                });
            }
            return acc;
        }, []);
        this.injector.logger.info("Socket events mounted:");
        const str = $log.drawTable(list, {
            padding: 1,
            header: {
                namespace: "Namespace",
                inputEvent: "Input event",
                outputEvent: "Output event",
                outputType: "Output type",
                name: "Class method"
            }
        });
        this.injector.logger.info("\n" + str.trim());
        this.injector.logger.info("Socket server started...");
    }
};
__decorate([
    Constant("logger.disableRoutesSummary", false),
    __metadata("design:type", Boolean)
], SocketIOModule.prototype, "disableRoutesSummary", void 0);
__decorate([
    Constant("socketIO", {}),
    __metadata("design:type", Object)
], SocketIOModule.prototype, "settings", void 0);
__decorate([
    Inject(),
    __metadata("design:type", InjectorService)
], SocketIOModule.prototype, "injector", void 0);
__decorate([
    Inject(Http.Server),
    __metadata("design:type", Object)
], SocketIOModule.prototype, "httpServer", void 0);
__decorate([
    Inject(Https.Server),
    __metadata("design:type", Object)
], SocketIOModule.prototype, "httpsServer", void 0);
__decorate([
    IO(),
    __metadata("design:type", Server)
], SocketIOModule.prototype, "io", void 0);
__decorate([
    Inject(),
    __metadata("design:type", SocketIOService)
], SocketIOModule.prototype, "socketIOService", void 0);
SocketIOModule = __decorate([
    Module()
], SocketIOModule);
export { SocketIOModule };
//# sourceMappingURL=SocketIOModule.js.map