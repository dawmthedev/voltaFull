import { isFunction, Store } from "@tsed/core";
import { DIContext, runInContext } from "@tsed/di";
import { deserialize } from "@tsed/json-mapper";
import { $log } from "@tsed/logger";
import { SocketFilters } from "../interfaces/SocketFilters.js";
import { SocketProviderTypes } from "../interfaces/SocketProviderTypes.js";
import { SocketReturnsTypes } from "../interfaces/SocketReturnsTypes.js";
import { SocketProviderMetadata } from "./SocketProviderMetadata.js";
import { SocketSessionData } from "./SocketSessionData.js";
import { v4 } from "uuid";
/**
 * @ignore
 */
export class SocketHandlersBuilder {
    constructor(provider, injector) {
        this.provider = provider;
        this.injector = injector;
        this.socketProviderMetadata = new SocketProviderMetadata(this.provider.store.get("socketIO"));
    }
    /**
     *
     * @param {SocketHandlerMetadata} handlerMetadata
     * @param scope
     * @returns {(data) => void}
     */
    static bindResponseMiddleware(handlerMetadata, scope) {
        const { returns } = handlerMetadata;
        return (response) => {
            if (returns) {
                switch (returns.type) {
                    case SocketReturnsTypes.BROADCAST:
                        scope.nsp.emit(returns.eventName, response);
                        break;
                    case SocketReturnsTypes.BROADCAST_OTHERS:
                        scope.socket.broadcast.emit(returns.eventName, response);
                        break;
                    case SocketReturnsTypes.EMIT:
                        scope.socket.emit(returns.eventName, response);
                        break;
                }
            }
            else {
                const cb = scope.args.at(-1);
                if (cb && isFunction(cb)) {
                    cb(response);
                }
            }
        };
    }
    /**
     *
     * @returns {any}
     */
    build(nsps) {
        const instance = this.injector.get(this.provider.token);
        const { injectNamespaces, namespace } = this.socketProviderMetadata;
        const nsp = nsps.get(namespace);
        instance.$onConnection && this.socketProviderMetadata.createHook("$onConnection", "connection");
        instance.$onDisconnect && this.socketProviderMetadata.createHook("$onDisconnect", "disconnect");
        injectNamespaces.forEach((setting) => {
            instance[setting.propertyKey] = nsps.get(setting.nsp || namespace);
        });
        instance["nsp"] = nsp;
        if (instance.$onNamespaceInit) {
            instance.$onNamespaceInit(nsp);
        }
        return this;
    }
    /**
     *
     * @param {Socket} socket
     * @param {Namespace} nsp
     */
    async onConnection(socket, nsp) {
        const { socketProviderMetadata } = this;
        const instance = this.injector.get(this.provider.token);
        this.buildHandlers(socket, nsp);
        if (instance.$onConnection) {
            const ctx = this.createContext(socket, nsp);
            await runInContext(ctx, () => this.invoke(instance, socketProviderMetadata.$onConnection, { socket, nsp }), this.injector);
        }
    }
    async onDisconnect(socket, nsp, reason) {
        const instance = this.injector.get(this.provider.token);
        const { socketProviderMetadata } = this;
        if (instance.$onDisconnect) {
            const ctx = this.createContext(socket, nsp);
            await runInContext(ctx, () => this.invoke(instance, socketProviderMetadata.$onDisconnect, { socket, nsp, reason }), this.injector);
        }
    }
    buildHandlers(socket, nsp) {
        const { socketProviderMetadata } = this;
        socketProviderMetadata.getHandlers().forEach((handler) => {
            const { eventName } = handler;
            if (eventName) {
                socket.on(eventName, async (...args) => {
                    const ctx = this.createContext(socket, nsp);
                    await runInContext(ctx, () => this.runQueue(handler, args, socket, nsp), this.injector);
                });
            }
        });
    }
    runQueue(handlerMetadata, args, socket, nsp) {
        const instance = this.injector.get(this.provider.token);
        const { useBefore, useAfter } = this.socketProviderMetadata;
        const scope = {
            args,
            socket,
            nsp,
            eventName: handlerMetadata.eventName
        };
        let promise = Promise.resolve().then(() => this.deserialize(handlerMetadata, scope));
        if (useBefore) {
            useBefore.forEach((target) => (promise = this.bindMiddleware(target, scope, promise)));
        }
        if (handlerMetadata.useBefore) {
            handlerMetadata.useBefore.forEach((target) => (promise = this.bindMiddleware(target, scope, promise)));
        }
        promise = promise
            .then(() => this.invoke(instance, handlerMetadata, scope))
            .then(SocketHandlersBuilder.bindResponseMiddleware(handlerMetadata, scope));
        if (handlerMetadata.useAfter) {
            handlerMetadata.useAfter.forEach((target) => (promise = this.bindMiddleware(target, scope, promise)));
        }
        if (useAfter) {
            useAfter.forEach((target) => (promise = this.bindMiddleware(target, scope, promise)));
        }
        return promise.catch((er) => {
            /* istanbul ignore next */
            $log.error(handlerMetadata.eventName, er);
        });
    }
    deserialize(handlerMetadata, scope) {
        const { parameters } = handlerMetadata;
        Object.keys(parameters || []).forEach((index) => {
            const { filter, useMapper, mapIndex, type, collectionType } = parameters[index];
            let value = scope.args[mapIndex];
            if (filter === SocketFilters.ARGS) {
                if (useMapper && typeof value !== "function") {
                    value = deserialize(value, {
                        type,
                        collectionType,
                        useAlias: true
                    });
                }
                scope.args[mapIndex] = value;
            }
        });
    }
    bindMiddleware(target, scope, promise) {
        const instance = this.injector.get(target);
        if (instance) {
            const handlerMetadata = new SocketProviderMetadata(Store.from(instance).get("socketIO"));
            if (handlerMetadata.type === SocketProviderTypes.MIDDLEWARE) {
                if (handlerMetadata.error) {
                    return promise.catch((error) => this.invoke(instance, handlerMetadata.useHandler, { error, ...scope }));
                }
                return promise
                    .then(() => this.invoke(instance, handlerMetadata.useHandler, scope))
                    .then((result) => {
                    if (result) {
                        scope.args = [].concat(result);
                    }
                });
            }
        }
        return promise;
    }
    invoke(instance, handlerMetadata, scope) {
        const { methodClassName, parameters } = handlerMetadata;
        return instance[methodClassName](...this.buildParameters(parameters, scope));
    }
    buildParameters(parameters, scope) {
        return Object.keys(parameters || []).map((index) => {
            const param = parameters[index];
            switch (param.filter) {
                case SocketFilters.ARGS:
                    if (param.mapIndex !== undefined) {
                        return scope.args[param.mapIndex];
                    }
                    return scope.args;
                case SocketFilters.EVENT_NAME:
                    return scope.eventName;
                case SocketFilters.SOCKET:
                    return scope.socket;
                case SocketFilters.NSP:
                    return scope.nsp;
                case SocketFilters.ERR:
                    return scope.error;
                case SocketFilters.SESSION:
                    return new SocketSessionData(scope.socket.data);
                case SocketFilters.RAW_SESSION:
                    return scope.socket.data;
                case SocketFilters.SOCKET_NSP:
                    return scope.socket.nsp;
                case SocketFilters.REASON:
                    return scope.reason;
            }
        });
    }
    createContext(socket, nsp) {
        return new DIContext({
            injector: this.injector,
            id: v4().split("-").join(""),
            logger: this.injector.logger,
            additionalProps: {
                module: "socket.io",
                sid: socket.id,
                namespace: nsp.name
            }
        });
    }
}
//# sourceMappingURL=SocketHandlersBuilder.js.map