"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Store = exports.PARAM_STORE = exports.PROPERTY_STORE = exports.METHOD_STORE = exports.CLASS_STORE = void 0;
const DecoratorTypes_js_1 = require("../domain/DecoratorTypes.js");
const decoratorTypeOf_js_1 = require("../utils/decorators/decoratorTypeOf.js");
const deepClone_js_1 = require("../utils/objects/deepClone.js");
const deepMerge_js_1 = require("../utils/objects/deepMerge.js");
const descriptorOf_js_1 = require("../utils/objects/descriptorOf.js");
const isSymbol_js_1 = require("../utils/objects/isSymbol.js");
const nameOf_js_1 = require("../utils/objects/nameOf.js");
const Metadata_js_1 = require("./Metadata.js");
/**
 * @ignore
 */
exports.CLASS_STORE = "tsed:class:store";
/**
 * @ignore
 */
exports.METHOD_STORE = "tsed:method:store";
/**
 * @ignore
 */
exports.PROPERTY_STORE = "tsed:property:store";
/**
 * @ignore
 */
exports.PARAM_STORE = "tsed:param:store";
const stores = new Map();
function storeGet(key, ...args) {
    if ((0, isSymbol_js_1.isSymbol)(args[0])) {
        if (!stores.has(args[0])) {
            stores.set(args[0], new Store());
        }
        return stores.get(args[0]);
    }
    else {
        const registry = Metadata_js_1.Metadata;
        if (!registry.hasOwn(key, ...args)) {
            registry.set(key, new Store(), ...args);
        }
        return registry.getOwn(key, ...args);
    }
}
function defineStore(args) {
    const [target, propertyKey, descriptor] = args;
    switch ((0, decoratorTypeOf_js_1.decoratorTypeOf)(args)) {
        case DecoratorTypes_js_1.DecoratorTypes.PARAM_CTOR:
        case DecoratorTypes_js_1.DecoratorTypes.PARAM_STC:
        case DecoratorTypes_js_1.DecoratorTypes.PARAM:
            const store = storeGet(exports.PARAM_STORE, target, propertyKey);
            if (!store.has("" + descriptor)) {
                store.set("" + descriptor, new Store());
            }
            return store.get("" + descriptor);
        case DecoratorTypes_js_1.DecoratorTypes.PROP:
        case DecoratorTypes_js_1.DecoratorTypes.PROP_STC:
            return storeGet(exports.PROPERTY_STORE, target, propertyKey);
        case DecoratorTypes_js_1.DecoratorTypes.METHOD:
        case DecoratorTypes_js_1.DecoratorTypes.METHOD_STC:
            return storeGet(exports.METHOD_STORE, target, propertyKey);
        case DecoratorTypes_js_1.DecoratorTypes.CLASS:
            return storeGet(exports.CLASS_STORE, target);
    }
}
class Store {
    constructor() {
        this._entries = new Map();
    }
    /**
     * Create or get a Store from args {target + methodName + descriptor}
     * @param args
     * @returns {Store}
     */
    static from(...args) {
        return defineStore(args);
    }
    /**
     * Create store on the method.
     * @param target
     * @param {string} propertyKey
     * @returns {Store}
     */
    static fromMethod(target, propertyKey) {
        return Store.from(target, propertyKey, (0, descriptorOf_js_1.descriptorOf)(target, propertyKey));
    }
    static mergeStoreFrom(target, source, ...args) {
        const store = Store.from(target, ...args);
        Store.from(source, ...args)._entries.forEach((value, key) => {
            store.merge(key, value);
        });
        return store;
    }
    static mergeStoreMethodFrom(target, source, propertyKey) {
        return this.mergeStoreFrom(target, source, propertyKey, (0, descriptorOf_js_1.descriptorOf)(target, propertyKey));
    }
    /**
     * The get() method returns a specified element from a Map object.
     * @param key Required. The key of the element to return from the Map object.
     * @param defaultValue
     * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
     */
    get(key, defaultValue) {
        return this._entries.get((0, nameOf_js_1.nameOf)(key)) || defaultValue;
    }
    /**
     * The has() method returns a boolean indicating whether an element with the specified key exists or not.
     * @param key
     * @returns {boolean}
     */
    has(key) {
        return this._entries.has((0, nameOf_js_1.nameOf)(key));
    }
    /**
     * The set() method adds or updates an element with a specified key and value to a Map object.
     * @param key Required. The key of the element to add to the Map object.
     * @param metadata Required. The value of the element to add to the Map object.
     */
    set(key, metadata) {
        this._entries.set((0, nameOf_js_1.nameOf)(key), metadata);
        return this;
    }
    /**
     * The delete() method removes the specified element from a Map object.
     * @param key Required. The key of the element to remove from the Map object.
     * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.
     */
    delete(key) {
        return this._entries.delete((0, nameOf_js_1.nameOf)(key));
    }
    /**
     * Merge given value with existing value.
     * @param key
     * @param value
     * @param inverse Change the merge order. Get the existing value and apply over given value
     * @returns {Store}
     */
    merge(key, value, inverse = false) {
        let _value_ = this.get(key);
        if (_value_) {
            value = (0, deepClone_js_1.deepClone)(value);
            _value_ = (0, deepClone_js_1.deepClone)(_value_);
            value = inverse ? (0, deepMerge_js_1.deepMerge)(value, _value_) : (0, deepMerge_js_1.deepMerge)(_value_, value);
        }
        this.set(key, value);
        return this;
    }
    toJson() {
        return [...this._entries.entries()].reduce((obj, [key, value]) => {
            return {
                ...obj,
                [key]: value
            };
        }, {});
    }
}
exports.Store = Store;
//# sourceMappingURL=Store.js.map